# Generated from Path.g4 by ANTLR 4.9.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3$")
        buf.write("\u014d\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\3\2\3\2\3\2\3\2\3\2\3\2\3\2\7\2T\n\2\f\2\16\2W\13\2")
        buf.write("\3\3\3\3\3\3\3\3\3\3\3\3\3\3\7\3`\n\3\f\3\16\3c\13\3\3")
        buf.write("\4\3\4\3\4\5\4h\n\4\3\4\3\4\7\4l\n\4\f\4\16\4o\13\4\3")
        buf.write("\5\3\5\6\5s\n\5\r\5\16\5t\3\5\6\5x\n\5\r\5\16\5y\3\5\6")
        buf.write("\5}\n\5\r\5\16\5~\3\5\6\5\u0082\n\5\r\5\16\5\u0083\3\5")
        buf.write("\3\5\6\5\u0088\n\5\r\5\16\5\u0089\3\5\6\5\u008d\n\5\r")
        buf.write("\5\16\5\u008e\3\5\6\5\u0092\n\5\r\5\16\5\u0093\3\5\6\5")
        buf.write("\u0097\n\5\r\5\16\5\u0098\3\5\6\5\u009c\n\5\r\5\16\5\u009d")
        buf.write("\3\5\6\5\u00a1\n\5\r\5\16\5\u00a2\3\5\6\5\u00a6\n\5\r")
        buf.write("\5\16\5\u00a7\5\5\u00aa\n\5\3\6\3\6\3\7\3\7\3\7\5\7\u00b1")
        buf.write("\n\7\3\7\3\7\7\7\u00b5\n\7\f\7\16\7\u00b8\13\7\3\b\6\b")
        buf.write("\u00bb\n\b\r\b\16\b\u00bc\3\b\6\b\u00c0\n\b\r\b\16\b\u00c1")
        buf.write("\3\b\6\b\u00c5\n\b\r\b\16\b\u00c6\3\b\6\b\u00ca\n\b\r")
        buf.write("\b\16\b\u00cb\3\b\6\b\u00cf\n\b\r\b\16\b\u00d0\3\b\6\b")
        buf.write("\u00d4\n\b\r\b\16\b\u00d5\3\b\6\b\u00d9\n\b\r\b\16\b\u00da")
        buf.write("\3\b\6\b\u00de\n\b\r\b\16\b\u00df\3\b\6\b\u00e3\n\b\r")
        buf.write("\b\16\b\u00e4\3\b\6\b\u00e8\n\b\r\b\16\b\u00e9\3\b\6\b")
        buf.write("\u00ed\n\b\r\b\16\b\u00ee\3\b\6\b\u00f2\n\b\r\b\16\b\u00f3")
        buf.write("\3\b\6\b\u00f7\n\b\r\b\16\b\u00f8\3\b\6\b\u00fc\n\b\r")
        buf.write("\b\16\b\u00fd\3\b\6\b\u0101\n\b\r\b\16\b\u0102\3\b\6\b")
        buf.write("\u0106\n\b\r\b\16\b\u0107\5\b\u010a\n\b\3\t\3\t\3\n\3")
        buf.write("\n\3\13\3\13\3\f\3\f\3\r\3\r\3\16\3\16\3\17\3\17\3\20")
        buf.write("\3\20\3\21\3\21\3\21\3\21\5\21\u0120\n\21\3\22\3\22\3")
        buf.write("\22\3\23\3\23\3\24\3\24\3\25\3\25\3\26\3\26\3\27\3\27")
        buf.write("\3\30\3\30\3\31\3\31\3\32\3\32\3\33\3\33\3\34\3\34\3\35")
        buf.write("\3\35\3\36\3\36\3\37\3\37\3 \3 \3!\3!\3\"\3\"\3#\3#\3")
        buf.write("$\3$\3%\3%\3&\3&\3&\2\6\2\4\6\f\'\2\4\6\b\n\f\16\20\22")
        buf.write("\24\26\30\32\34\36 \"$&(*,.\60\62\64\668:<>@BDFHJ\2\3")
        buf.write("\3\2\3\4\2\u0165\2L\3\2\2\2\4X\3\2\2\2\6g\3\2\2\2\b\u00a9")
        buf.write("\3\2\2\2\n\u00ab\3\2\2\2\f\u00b0\3\2\2\2\16\u0109\3\2")
        buf.write("\2\2\20\u010b\3\2\2\2\22\u010d\3\2\2\2\24\u010f\3\2\2")
        buf.write("\2\26\u0111\3\2\2\2\30\u0113\3\2\2\2\32\u0115\3\2\2\2")
        buf.write("\34\u0117\3\2\2\2\36\u0119\3\2\2\2 \u011f\3\2\2\2\"\u0121")
        buf.write("\3\2\2\2$\u0124\3\2\2\2&\u0126\3\2\2\2(\u0128\3\2\2\2")
        buf.write("*\u012a\3\2\2\2,\u012c\3\2\2\2.\u012e\3\2\2\2\60\u0130")
        buf.write("\3\2\2\2\62\u0132\3\2\2\2\64\u0134\3\2\2\2\66\u0136\3")
        buf.write("\2\2\28\u0138\3\2\2\2:\u013a\3\2\2\2<\u013c\3\2\2\2>\u013e")
        buf.write("\3\2\2\2@\u0140\3\2\2\2B\u0142\3\2\2\2D\u0144\3\2\2\2")
        buf.write("F\u0146\3\2\2\2H\u0148\3\2\2\2J\u014a\3\2\2\2LM\b\2\1")
        buf.write("\2MN\5\4\3\2NU\3\2\2\2OP\f\5\2\2PT\5\4\3\2QR\f\4\2\2R")
        buf.write("T\5.\30\2SO\3\2\2\2SQ\3\2\2\2TW\3\2\2\2US\3\2\2\2UV\3")
        buf.write("\2\2\2V\3\3\2\2\2WU\3\2\2\2XY\b\3\1\2YZ\5\6\4\2Za\3\2")
        buf.write("\2\2[\\\f\4\2\2\\]\5\f\7\2]^\5\4\3\5^`\3\2\2\2_[\3\2\2")
        buf.write("\2`c\3\2\2\2a_\3\2\2\2ab\3\2\2\2b\5\3\2\2\2ca\3\2\2\2")
        buf.write("de\b\4\1\2eh\5\n\6\2fh\5\b\5\2gd\3\2\2\2gf\3\2\2\2hm\3")
        buf.write("\2\2\2ij\f\5\2\2jl\5\6\4\6ki\3\2\2\2lo\3\2\2\2mk\3\2\2")
        buf.write("\2mn\3\2\2\2n\7\3\2\2\2om\3\2\2\2p\u00aa\5\34\17\2qs\5")
        buf.write("(\25\2rq\3\2\2\2st\3\2\2\2tr\3\2\2\2tu\3\2\2\2u\u00aa")
        buf.write("\3\2\2\2vx\5\64\33\2wv\3\2\2\2xy\3\2\2\2yw\3\2\2\2yz\3")
        buf.write("\2\2\2z\u00aa\3\2\2\2{}\5\60\31\2|{\3\2\2\2}~\3\2\2\2")
        buf.write("~|\3\2\2\2~\177\3\2\2\2\177\u00aa\3\2\2\2\u0080\u0082")
        buf.write("\7\7\2\2\u0081\u0080\3\2\2\2\u0082\u0083\3\2\2\2\u0083")
        buf.write("\u0081\3\2\2\2\u0083\u0084\3\2\2\2\u0084\u00aa\3\2\2\2")
        buf.write("\u0085\u00aa\7\b\2\2\u0086\u0088\5@!\2\u0087\u0086\3\2")
        buf.write("\2\2\u0088\u0089\3\2\2\2\u0089\u0087\3\2\2\2\u0089\u008a")
        buf.write("\3\2\2\2\u008a\u00aa\3\2\2\2\u008b\u008d\5\66\34\2\u008c")
        buf.write("\u008b\3\2\2\2\u008d\u008e\3\2\2\2\u008e\u008c\3\2\2\2")
        buf.write("\u008e\u008f\3\2\2\2\u008f\u00aa\3\2\2\2\u0090\u0092\5")
        buf.write("\36\20\2\u0091\u0090\3\2\2\2\u0092\u0093\3\2\2\2\u0093")
        buf.write("\u0091\3\2\2\2\u0093\u0094\3\2\2\2\u0094\u00aa\3\2\2\2")
        buf.write("\u0095\u0097\58\35\2\u0096\u0095\3\2\2\2\u0097\u0098\3")
        buf.write("\2\2\2\u0098\u0096\3\2\2\2\u0098\u0099\3\2\2\2\u0099\u00aa")
        buf.write("\3\2\2\2\u009a\u009c\5\26\f\2\u009b\u009a\3\2\2\2\u009c")
        buf.write("\u009d\3\2\2\2\u009d\u009b\3\2\2\2\u009d\u009e\3\2\2\2")
        buf.write("\u009e\u00aa\3\2\2\2\u009f\u00a1\5\16\b\2\u00a0\u009f")
        buf.write("\3\2\2\2\u00a1\u00a2\3\2\2\2\u00a2\u00a0\3\2\2\2\u00a2")
        buf.write("\u00a3\3\2\2\2\u00a3\u00aa\3\2\2\2\u00a4\u00a6\5\62\32")
        buf.write("\2\u00a5\u00a4\3\2\2\2\u00a6\u00a7\3\2\2\2\u00a7\u00a5")
        buf.write("\3\2\2\2\u00a7\u00a8\3\2\2\2\u00a8\u00aa\3\2\2\2\u00a9")
        buf.write("p\3\2\2\2\u00a9r\3\2\2\2\u00a9w\3\2\2\2\u00a9|\3\2\2\2")
        buf.write("\u00a9\u0081\3\2\2\2\u00a9\u0085\3\2\2\2\u00a9\u0087\3")
        buf.write("\2\2\2\u00a9\u008c\3\2\2\2\u00a9\u0091\3\2\2\2\u00a9\u0096")
        buf.write("\3\2\2\2\u00a9\u009b\3\2\2\2\u00a9\u00a0\3\2\2\2\u00a9")
        buf.write("\u00a5\3\2\2\2\u00aa\t\3\2\2\2\u00ab\u00ac\t\2\2\2\u00ac")
        buf.write("\13\3\2\2\2\u00ad\u00ae\b\7\1\2\u00ae\u00b1\7\7\2\2\u00af")
        buf.write("\u00b1\7\b\2\2\u00b0\u00ad\3\2\2\2\u00b0\u00af\3\2\2\2")
        buf.write("\u00b1\u00b6\3\2\2\2\u00b2\u00b3\f\5\2\2\u00b3\u00b5\5")
        buf.write("\f\7\6\u00b4\u00b2\3\2\2\2\u00b5\u00b8\3\2\2\2\u00b6\u00b4")
        buf.write("\3\2\2\2\u00b6\u00b7\3\2\2\2\u00b7\r\3\2\2\2\u00b8\u00b6")
        buf.write("\3\2\2\2\u00b9\u00bb\5> \2\u00ba\u00b9\3\2\2\2\u00bb\u00bc")
        buf.write("\3\2\2\2\u00bc\u00ba\3\2\2\2\u00bc\u00bd\3\2\2\2\u00bd")
        buf.write("\u010a\3\2\2\2\u00be\u00c0\5<\37\2\u00bf\u00be\3\2\2\2")
        buf.write("\u00c0\u00c1\3\2\2\2\u00c1\u00bf\3\2\2\2\u00c1\u00c2\3")
        buf.write("\2\2\2\u00c2\u010a\3\2\2\2\u00c3\u00c5\5:\36\2\u00c4\u00c3")
        buf.write("\3\2\2\2\u00c5\u00c6\3\2\2\2\u00c6\u00c4\3\2\2\2\u00c6")
        buf.write("\u00c7\3\2\2\2\u00c7\u010a\3\2\2\2\u00c8\u00ca\5B\"\2")
        buf.write("\u00c9\u00c8\3\2\2\2\u00ca\u00cb\3\2\2\2\u00cb\u00c9\3")
        buf.write("\2\2\2\u00cb\u00cc\3\2\2\2\u00cc\u010a\3\2\2\2\u00cd\u00cf")
        buf.write("\5D#\2\u00ce\u00cd\3\2\2\2\u00cf\u00d0\3\2\2\2\u00d0\u00ce")
        buf.write("\3\2\2\2\u00d0\u00d1\3\2\2\2\u00d1\u010a\3\2\2\2\u00d2")
        buf.write("\u00d4\5F$\2\u00d3\u00d2\3\2\2\2\u00d4\u00d5\3\2\2\2\u00d5")
        buf.write("\u00d3\3\2\2\2\u00d5\u00d6\3\2\2\2\u00d6\u010a\3\2\2\2")
        buf.write("\u00d7\u00d9\5H%\2\u00d8\u00d7\3\2\2\2\u00d9\u00da\3\2")
        buf.write("\2\2\u00da\u00d8\3\2\2\2\u00da\u00db\3\2\2\2\u00db\u010a")
        buf.write("\3\2\2\2\u00dc\u00de\5\22\n\2\u00dd\u00dc\3\2\2\2\u00de")
        buf.write("\u00df\3\2\2\2\u00df\u00dd\3\2\2\2\u00df\u00e0\3\2\2\2")
        buf.write("\u00e0\u010a\3\2\2\2\u00e1\u00e3\5,\27\2\u00e2\u00e1\3")
        buf.write("\2\2\2\u00e3\u00e4\3\2\2\2\u00e4\u00e2\3\2\2\2\u00e4\u00e5")
        buf.write("\3\2\2\2\u00e5\u010a\3\2\2\2\u00e6\u00e8\5*\26\2\u00e7")
        buf.write("\u00e6\3\2\2\2\u00e8\u00e9\3\2\2\2\u00e9\u00e7\3\2\2\2")
        buf.write("\u00e9\u00ea\3\2\2\2\u00ea\u010a\3\2\2\2\u00eb\u00ed\5")
        buf.write("\24\13\2\u00ec\u00eb\3\2\2\2\u00ed\u00ee\3\2\2\2\u00ee")
        buf.write("\u00ec\3\2\2\2\u00ee\u00ef\3\2\2\2\u00ef\u010a\3\2\2\2")
        buf.write("\u00f0\u00f2\5J&\2\u00f1\u00f0\3\2\2\2\u00f2\u00f3\3\2")
        buf.write("\2\2\u00f3\u00f1\3\2\2\2\u00f3\u00f4\3\2\2\2\u00f4\u010a")
        buf.write("\3\2\2\2\u00f5\u00f7\5\30\r\2\u00f6\u00f5\3\2\2\2\u00f7")
        buf.write("\u00f8\3\2\2\2\u00f8\u00f6\3\2\2\2\u00f8\u00f9\3\2\2\2")
        buf.write("\u00f9\u010a\3\2\2\2\u00fa\u00fc\5\32\16\2\u00fb\u00fa")
        buf.write("\3\2\2\2\u00fc\u00fd\3\2\2\2\u00fd\u00fb\3\2\2\2\u00fd")
        buf.write("\u00fe\3\2\2\2\u00fe\u010a\3\2\2\2\u00ff\u0101\5$\23\2")
        buf.write("\u0100\u00ff\3\2\2\2\u0101\u0102\3\2\2\2\u0102\u0100\3")
        buf.write("\2\2\2\u0102\u0103\3\2\2\2\u0103\u010a\3\2\2\2\u0104\u0106")
        buf.write("\5&\24\2\u0105\u0104\3\2\2\2\u0106\u0107\3\2\2\2\u0107")
        buf.write("\u0105\3\2\2\2\u0107\u0108\3\2\2\2\u0108\u010a\3\2\2\2")
        buf.write("\u0109\u00ba\3\2\2\2\u0109\u00bf\3\2\2\2\u0109\u00c4\3")
        buf.write("\2\2\2\u0109\u00c9\3\2\2\2\u0109\u00ce\3\2\2\2\u0109\u00d3")
        buf.write("\3\2\2\2\u0109\u00d8\3\2\2\2\u0109\u00dd\3\2\2\2\u0109")
        buf.write("\u00e2\3\2\2\2\u0109\u00e7\3\2\2\2\u0109\u00ec\3\2\2\2")
        buf.write("\u0109\u00f1\3\2\2\2\u0109\u00f6\3\2\2\2\u0109\u00fb\3")
        buf.write("\2\2\2\u0109\u0100\3\2\2\2\u0109\u0105\3\2\2\2\u010a\17")
        buf.write("\3\2\2\2\u010b\u010c\7\3\2\2\u010c\21\3\2\2\2\u010d\u010e")
        buf.write("\7\36\2\2\u010e\23\3\2\2\2\u010f\u0110\7\37\2\2\u0110")
        buf.write("\25\3\2\2\2\u0111\u0112\7\17\2\2\u0112\27\3\2\2\2\u0113")
        buf.write("\u0114\7\"\2\2\u0114\31\3\2\2\2\u0115\u0116\7#\2\2\u0116")
        buf.write("\33\3\2\2\2\u0117\u0118\7\r\2\2\u0118\35\3\2\2\2\u0119")
        buf.write("\u011a\7\26\2\2\u011a\37\3\2\2\2\u011b\u0120\7$\2\2\u011c")
        buf.write("\u011d\5\"\22\2\u011d\u011e\7\7\2\2\u011e\u0120\3\2\2")
        buf.write("\2\u011f\u011b\3\2\2\2\u011f\u011c\3\2\2\2\u0120!\3\2")
        buf.write("\2\2\u0121\u0122\5\34\17\2\u0122\u0123\5\34\17\2\u0123")
        buf.write("#\3\2\2\2\u0124\u0125\7\13\2\2\u0125%\3\2\2\2\u0126\u0127")
        buf.write("\7\f\2\2\u0127\'\3\2\2\2\u0128\u0129\7\16\2\2\u0129)\3")
        buf.write("\2\2\2\u012a\u012b\7\24\2\2\u012b+\3\2\2\2\u012c\u012d")
        buf.write("\7!\2\2\u012d-\3\2\2\2\u012e\u012f\7\6\2\2\u012f/\3\2")
        buf.write("\2\2\u0130\u0131\7\5\2\2\u0131\61\3\2\2\2\u0132\u0133")
        buf.write("\7\20\2\2\u0133\63\3\2\2\2\u0134\u0135\7\25\2\2\u0135")
        buf.write("\65\3\2\2\2\u0136\u0137\7\21\2\2\u0137\67\3\2\2\2\u0138")
        buf.write("\u0139\7\22\2\2\u01399\3\2\2\2\u013a\u013b\7\30\2\2\u013b")
        buf.write(";\3\2\2\2\u013c\u013d\7\31\2\2\u013d=\3\2\2\2\u013e\u013f")
        buf.write("\7\27\2\2\u013f?\3\2\2\2\u0140\u0141\7\23\2\2\u0141A\3")
        buf.write("\2\2\2\u0142\u0143\7\32\2\2\u0143C\3\2\2\2\u0144\u0145")
        buf.write("\7\33\2\2\u0145E\3\2\2\2\u0146\u0147\7\34\2\2\u0147G\3")
        buf.write("\2\2\2\u0148\u0149\7\35\2\2\u0149I\3\2\2\2\u014a\u014b")
        buf.write("\7 \2\2\u014bK\3\2\2\2\'SUagmty~\u0083\u0089\u008e\u0093")
        buf.write("\u0098\u009d\u00a2\u00a7\u00a9\u00b0\u00b6\u00bc\u00c1")
        buf.write("\u00c6\u00cb\u00d0\u00d5\u00da\u00df\u00e4\u00e9\u00ee")
        buf.write("\u00f3\u00f8\u00fd\u0102\u0107\u0109\u011f")
        return buf.getvalue()


class PathParser ( Parser ):

    grammarFileName = "Path.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "'%2f'", "'/'", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'*'", "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "'~'" ]

    symbolicNames = [ "<INVALID>", "LET_DIG_S_LET", "LET_DIG", "SLASH_HEX", 
                      "SLASH", "WS", "CAMMA", "DIGIT", "LETTER", "QUOTE", 
                      "DQUOTE", "HYPHEN", "US", "EQ", "DOT", "B_SLASH", 
                      "QM", "PERCENT", "CH_AND", "COLON", "SEMI_COLON", 
                      "STAR", "PAR_O", "PAR_C", "BRACK", "ACOLAD", "DOLLAR", 
                      "ADSGN", "EXCAM_SGN", "BIN_INVERT", "IRG_SGN1", "CH_OR", 
                      "LT_SGN", "GT_SGN", "HASHTAG" ]

    RULE_path = 0
    RULE_p_value = 1
    RULE_value = 2
    RULE_ilg = 3
    RULE_label = 4
    RULE_delim = 5
    RULE_ch_ilg = 6
    RULE_ldse = 7
    RULE_opNot = 8
    RULE_opBinInvert = 9
    RULE_opEqual = 10
    RULE_opLt = 11
    RULE_opGt = 12
    RULE_opMinus = 13
    RULE_opSem = 14
    RULE_cmt = 15
    RULE_ddash = 16
    RULE_quote = 17
    RULE_dquote = 18
    RULE_us_sgn = 19
    RULE_c_and = 20
    RULE_c_or = 21
    RULE_c_slash = 22
    RULE_c_slash_hex = 23
    RULE_c_dot = 24
    RULE_c_colon = 25
    RULE_s_bslash = 26
    RULE_c_q = 27
    RULE_par_open = 28
    RULE_par_close = 29
    RULE_c_star = 30
    RULE_c_percent = 31
    RULE_c_brack = 32
    RULE_c_acolad = 33
    RULE_c_dollar = 34
    RULE_c_adsgn = 35
    RULE_c_irg1 = 36

    ruleNames =  [ "path", "p_value", "value", "ilg", "label", "delim", 
                   "ch_ilg", "ldse", "opNot", "opBinInvert", "opEqual", 
                   "opLt", "opGt", "opMinus", "opSem", "cmt", "ddash", "quote", 
                   "dquote", "us_sgn", "c_and", "c_or", "c_slash", "c_slash_hex", 
                   "c_dot", "c_colon", "s_bslash", "c_q", "par_open", "par_close", 
                   "c_star", "c_percent", "c_brack", "c_acolad", "c_dollar", 
                   "c_adsgn", "c_irg1" ]

    EOF = Token.EOF
    LET_DIG_S_LET=1
    LET_DIG=2
    SLASH_HEX=3
    SLASH=4
    WS=5
    CAMMA=6
    DIGIT=7
    LETTER=8
    QUOTE=9
    DQUOTE=10
    HYPHEN=11
    US=12
    EQ=13
    DOT=14
    B_SLASH=15
    QM=16
    PERCENT=17
    CH_AND=18
    COLON=19
    SEMI_COLON=20
    STAR=21
    PAR_O=22
    PAR_C=23
    BRACK=24
    ACOLAD=25
    DOLLAR=26
    ADSGN=27
    EXCAM_SGN=28
    BIN_INVERT=29
    IRG_SGN1=30
    CH_OR=31
    LT_SGN=32
    GT_SGN=33
    HASHTAG=34

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class PathContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def p_value(self):
            return self.getTypedRuleContext(PathParser.P_valueContext,0)


        def path(self):
            return self.getTypedRuleContext(PathParser.PathContext,0)


        def c_slash(self):
            return self.getTypedRuleContext(PathParser.C_slashContext,0)


        def getRuleIndex(self):
            return PathParser.RULE_path

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPath" ):
                listener.enterPath(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPath" ):
                listener.exitPath(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPath" ):
                return visitor.visitPath(self)
            else:
                return visitor.visitChildren(self)



    def path(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = PathParser.PathContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 0
        self.enterRecursionRule(localctx, 0, self.RULE_path, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 75
            self.p_value(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 83
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,1,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 81
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,0,self._ctx)
                    if la_ == 1:
                        localctx = PathParser.PathContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_path)
                        self.state = 77
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 78
                        self.p_value(0)
                        pass

                    elif la_ == 2:
                        localctx = PathParser.PathContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_path)
                        self.state = 79
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 80
                        self.c_slash()
                        pass

             
                self.state = 85
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,1,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class P_valueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def value(self):
            return self.getTypedRuleContext(PathParser.ValueContext,0)


        def p_value(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PathParser.P_valueContext)
            else:
                return self.getTypedRuleContext(PathParser.P_valueContext,i)


        def delim(self):
            return self.getTypedRuleContext(PathParser.DelimContext,0)


        def getRuleIndex(self):
            return PathParser.RULE_p_value

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterP_value" ):
                listener.enterP_value(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitP_value" ):
                listener.exitP_value(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitP_value" ):
                return visitor.visitP_value(self)
            else:
                return visitor.visitChildren(self)



    def p_value(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = PathParser.P_valueContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 2
        self.enterRecursionRule(localctx, 2, self.RULE_p_value, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 87
            self.value(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 95
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,2,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = PathParser.P_valueContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_p_value)
                    self.state = 89
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 90
                    self.delim(0)
                    self.state = 91
                    self.p_value(3) 
                self.state = 97
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,2,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class ValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def label(self):
            return self.getTypedRuleContext(PathParser.LabelContext,0)


        def ilg(self):
            return self.getTypedRuleContext(PathParser.IlgContext,0)


        def value(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PathParser.ValueContext)
            else:
                return self.getTypedRuleContext(PathParser.ValueContext,i)


        def getRuleIndex(self):
            return PathParser.RULE_value

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterValue" ):
                listener.enterValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitValue" ):
                listener.exitValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitValue" ):
                return visitor.visitValue(self)
            else:
                return visitor.visitChildren(self)



    def value(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = PathParser.ValueContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 4
        self.enterRecursionRule(localctx, 4, self.RULE_value, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 101
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PathParser.LET_DIG_S_LET, PathParser.LET_DIG]:
                self.state = 99
                self.label()
                pass
            elif token in [PathParser.SLASH_HEX, PathParser.WS, PathParser.CAMMA, PathParser.QUOTE, PathParser.DQUOTE, PathParser.HYPHEN, PathParser.US, PathParser.EQ, PathParser.DOT, PathParser.B_SLASH, PathParser.QM, PathParser.PERCENT, PathParser.CH_AND, PathParser.COLON, PathParser.SEMI_COLON, PathParser.STAR, PathParser.PAR_O, PathParser.PAR_C, PathParser.BRACK, PathParser.ACOLAD, PathParser.DOLLAR, PathParser.ADSGN, PathParser.EXCAM_SGN, PathParser.BIN_INVERT, PathParser.IRG_SGN1, PathParser.CH_OR, PathParser.LT_SGN, PathParser.GT_SGN]:
                self.state = 100
                self.ilg()
                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 107
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,4,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = PathParser.ValueContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_value)
                    self.state = 103
                    if not self.precpred(self._ctx, 3):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                    self.state = 104
                    self.value(4) 
                self.state = 109
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,4,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class IlgContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opMinus(self):
            return self.getTypedRuleContext(PathParser.OpMinusContext,0)


        def us_sgn(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PathParser.Us_sgnContext)
            else:
                return self.getTypedRuleContext(PathParser.Us_sgnContext,i)


        def c_colon(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PathParser.C_colonContext)
            else:
                return self.getTypedRuleContext(PathParser.C_colonContext,i)


        def c_slash_hex(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PathParser.C_slash_hexContext)
            else:
                return self.getTypedRuleContext(PathParser.C_slash_hexContext,i)


        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(PathParser.WS)
            else:
                return self.getToken(PathParser.WS, i)

        def CAMMA(self):
            return self.getToken(PathParser.CAMMA, 0)

        def c_percent(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PathParser.C_percentContext)
            else:
                return self.getTypedRuleContext(PathParser.C_percentContext,i)


        def s_bslash(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PathParser.S_bslashContext)
            else:
                return self.getTypedRuleContext(PathParser.S_bslashContext,i)


        def opSem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PathParser.OpSemContext)
            else:
                return self.getTypedRuleContext(PathParser.OpSemContext,i)


        def c_q(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PathParser.C_qContext)
            else:
                return self.getTypedRuleContext(PathParser.C_qContext,i)


        def opEqual(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PathParser.OpEqualContext)
            else:
                return self.getTypedRuleContext(PathParser.OpEqualContext,i)


        def ch_ilg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PathParser.Ch_ilgContext)
            else:
                return self.getTypedRuleContext(PathParser.Ch_ilgContext,i)


        def c_dot(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PathParser.C_dotContext)
            else:
                return self.getTypedRuleContext(PathParser.C_dotContext,i)


        def getRuleIndex(self):
            return PathParser.RULE_ilg

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIlg" ):
                listener.enterIlg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIlg" ):
                listener.exitIlg(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIlg" ):
                return visitor.visitIlg(self)
            else:
                return visitor.visitChildren(self)




    def ilg(self):

        localctx = PathParser.IlgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_ilg)
        try:
            self.state = 167
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PathParser.HYPHEN]:
                self.enterOuterAlt(localctx, 1)
                self.state = 110
                self.opMinus()
                pass
            elif token in [PathParser.US]:
                self.enterOuterAlt(localctx, 2)
                self.state = 112 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 111
                        self.us_sgn()

                    else:
                        raise NoViableAltException(self)
                    self.state = 114 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,5,self._ctx)

                pass
            elif token in [PathParser.COLON]:
                self.enterOuterAlt(localctx, 3)
                self.state = 117 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 116
                        self.c_colon()

                    else:
                        raise NoViableAltException(self)
                    self.state = 119 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,6,self._ctx)

                pass
            elif token in [PathParser.SLASH_HEX]:
                self.enterOuterAlt(localctx, 4)
                self.state = 122 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 121
                        self.c_slash_hex()

                    else:
                        raise NoViableAltException(self)
                    self.state = 124 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,7,self._ctx)

                pass
            elif token in [PathParser.WS]:
                self.enterOuterAlt(localctx, 5)
                self.state = 127 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 126
                        self.match(PathParser.WS)

                    else:
                        raise NoViableAltException(self)
                    self.state = 129 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,8,self._ctx)

                pass
            elif token in [PathParser.CAMMA]:
                self.enterOuterAlt(localctx, 6)
                self.state = 131
                self.match(PathParser.CAMMA)
                pass
            elif token in [PathParser.PERCENT]:
                self.enterOuterAlt(localctx, 7)
                self.state = 133 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 132
                        self.c_percent()

                    else:
                        raise NoViableAltException(self)
                    self.state = 135 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,9,self._ctx)

                pass
            elif token in [PathParser.B_SLASH]:
                self.enterOuterAlt(localctx, 8)
                self.state = 138 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 137
                        self.s_bslash()

                    else:
                        raise NoViableAltException(self)
                    self.state = 140 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,10,self._ctx)

                pass
            elif token in [PathParser.SEMI_COLON]:
                self.enterOuterAlt(localctx, 9)
                self.state = 143 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 142
                        self.opSem()

                    else:
                        raise NoViableAltException(self)
                    self.state = 145 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,11,self._ctx)

                pass
            elif token in [PathParser.QM]:
                self.enterOuterAlt(localctx, 10)
                self.state = 148 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 147
                        self.c_q()

                    else:
                        raise NoViableAltException(self)
                    self.state = 150 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,12,self._ctx)

                pass
            elif token in [PathParser.EQ]:
                self.enterOuterAlt(localctx, 11)
                self.state = 153 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 152
                        self.opEqual()

                    else:
                        raise NoViableAltException(self)
                    self.state = 155 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,13,self._ctx)

                pass
            elif token in [PathParser.QUOTE, PathParser.DQUOTE, PathParser.CH_AND, PathParser.STAR, PathParser.PAR_O, PathParser.PAR_C, PathParser.BRACK, PathParser.ACOLAD, PathParser.DOLLAR, PathParser.ADSGN, PathParser.EXCAM_SGN, PathParser.BIN_INVERT, PathParser.IRG_SGN1, PathParser.CH_OR, PathParser.LT_SGN, PathParser.GT_SGN]:
                self.enterOuterAlt(localctx, 12)
                self.state = 158 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 157
                        self.ch_ilg()

                    else:
                        raise NoViableAltException(self)
                    self.state = 160 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,14,self._ctx)

                pass
            elif token in [PathParser.DOT]:
                self.enterOuterAlt(localctx, 13)
                self.state = 163 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 162
                        self.c_dot()

                    else:
                        raise NoViableAltException(self)
                    self.state = 165 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,15,self._ctx)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LabelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LET_DIG_S_LET(self):
            return self.getToken(PathParser.LET_DIG_S_LET, 0)

        def LET_DIG(self):
            return self.getToken(PathParser.LET_DIG, 0)

        def getRuleIndex(self):
            return PathParser.RULE_label

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabel" ):
                listener.enterLabel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabel" ):
                listener.exitLabel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLabel" ):
                return visitor.visitLabel(self)
            else:
                return visitor.visitChildren(self)




    def label(self):

        localctx = PathParser.LabelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_label)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 169
            _la = self._input.LA(1)
            if not(_la==PathParser.LET_DIG_S_LET or _la==PathParser.LET_DIG):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DelimContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WS(self):
            return self.getToken(PathParser.WS, 0)

        def CAMMA(self):
            return self.getToken(PathParser.CAMMA, 0)

        def delim(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PathParser.DelimContext)
            else:
                return self.getTypedRuleContext(PathParser.DelimContext,i)


        def getRuleIndex(self):
            return PathParser.RULE_delim

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDelim" ):
                listener.enterDelim(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDelim" ):
                listener.exitDelim(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDelim" ):
                return visitor.visitDelim(self)
            else:
                return visitor.visitChildren(self)



    def delim(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = PathParser.DelimContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 10
        self.enterRecursionRule(localctx, 10, self.RULE_delim, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 174
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PathParser.WS]:
                self.state = 172
                self.match(PathParser.WS)
                pass
            elif token in [PathParser.CAMMA]:
                self.state = 173
                self.match(PathParser.CAMMA)
                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 180
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,18,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = PathParser.DelimContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_delim)
                    self.state = 176
                    if not self.precpred(self._ctx, 3):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                    self.state = 177
                    self.delim(4) 
                self.state = 182
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,18,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class Ch_ilgContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def c_star(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PathParser.C_starContext)
            else:
                return self.getTypedRuleContext(PathParser.C_starContext,i)


        def par_close(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PathParser.Par_closeContext)
            else:
                return self.getTypedRuleContext(PathParser.Par_closeContext,i)


        def par_open(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PathParser.Par_openContext)
            else:
                return self.getTypedRuleContext(PathParser.Par_openContext,i)


        def c_brack(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PathParser.C_brackContext)
            else:
                return self.getTypedRuleContext(PathParser.C_brackContext,i)


        def c_acolad(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PathParser.C_acoladContext)
            else:
                return self.getTypedRuleContext(PathParser.C_acoladContext,i)


        def c_dollar(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PathParser.C_dollarContext)
            else:
                return self.getTypedRuleContext(PathParser.C_dollarContext,i)


        def c_adsgn(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PathParser.C_adsgnContext)
            else:
                return self.getTypedRuleContext(PathParser.C_adsgnContext,i)


        def opNot(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PathParser.OpNotContext)
            else:
                return self.getTypedRuleContext(PathParser.OpNotContext,i)


        def c_or(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PathParser.C_orContext)
            else:
                return self.getTypedRuleContext(PathParser.C_orContext,i)


        def c_and(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PathParser.C_andContext)
            else:
                return self.getTypedRuleContext(PathParser.C_andContext,i)


        def opBinInvert(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PathParser.OpBinInvertContext)
            else:
                return self.getTypedRuleContext(PathParser.OpBinInvertContext,i)


        def c_irg1(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PathParser.C_irg1Context)
            else:
                return self.getTypedRuleContext(PathParser.C_irg1Context,i)


        def opLt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PathParser.OpLtContext)
            else:
                return self.getTypedRuleContext(PathParser.OpLtContext,i)


        def opGt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PathParser.OpGtContext)
            else:
                return self.getTypedRuleContext(PathParser.OpGtContext,i)


        def quote(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PathParser.QuoteContext)
            else:
                return self.getTypedRuleContext(PathParser.QuoteContext,i)


        def dquote(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PathParser.DquoteContext)
            else:
                return self.getTypedRuleContext(PathParser.DquoteContext,i)


        def getRuleIndex(self):
            return PathParser.RULE_ch_ilg

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCh_ilg" ):
                listener.enterCh_ilg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCh_ilg" ):
                listener.exitCh_ilg(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCh_ilg" ):
                return visitor.visitCh_ilg(self)
            else:
                return visitor.visitChildren(self)




    def ch_ilg(self):

        localctx = PathParser.Ch_ilgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_ch_ilg)
        try:
            self.state = 263
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PathParser.STAR]:
                self.enterOuterAlt(localctx, 1)
                self.state = 184 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 183
                        self.c_star()

                    else:
                        raise NoViableAltException(self)
                    self.state = 186 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,19,self._ctx)

                pass
            elif token in [PathParser.PAR_C]:
                self.enterOuterAlt(localctx, 2)
                self.state = 189 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 188
                        self.par_close()

                    else:
                        raise NoViableAltException(self)
                    self.state = 191 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,20,self._ctx)

                pass
            elif token in [PathParser.PAR_O]:
                self.enterOuterAlt(localctx, 3)
                self.state = 194 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 193
                        self.par_open()

                    else:
                        raise NoViableAltException(self)
                    self.state = 196 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,21,self._ctx)

                pass
            elif token in [PathParser.BRACK]:
                self.enterOuterAlt(localctx, 4)
                self.state = 199 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 198
                        self.c_brack()

                    else:
                        raise NoViableAltException(self)
                    self.state = 201 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,22,self._ctx)

                pass
            elif token in [PathParser.ACOLAD]:
                self.enterOuterAlt(localctx, 5)
                self.state = 204 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 203
                        self.c_acolad()

                    else:
                        raise NoViableAltException(self)
                    self.state = 206 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,23,self._ctx)

                pass
            elif token in [PathParser.DOLLAR]:
                self.enterOuterAlt(localctx, 6)
                self.state = 209 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 208
                        self.c_dollar()

                    else:
                        raise NoViableAltException(self)
                    self.state = 211 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,24,self._ctx)

                pass
            elif token in [PathParser.ADSGN]:
                self.enterOuterAlt(localctx, 7)
                self.state = 214 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 213
                        self.c_adsgn()

                    else:
                        raise NoViableAltException(self)
                    self.state = 216 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,25,self._ctx)

                pass
            elif token in [PathParser.EXCAM_SGN]:
                self.enterOuterAlt(localctx, 8)
                self.state = 219 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 218
                        self.opNot()

                    else:
                        raise NoViableAltException(self)
                    self.state = 221 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,26,self._ctx)

                pass
            elif token in [PathParser.CH_OR]:
                self.enterOuterAlt(localctx, 9)
                self.state = 224 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 223
                        self.c_or()

                    else:
                        raise NoViableAltException(self)
                    self.state = 226 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,27,self._ctx)

                pass
            elif token in [PathParser.CH_AND]:
                self.enterOuterAlt(localctx, 10)
                self.state = 229 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 228
                        self.c_and()

                    else:
                        raise NoViableAltException(self)
                    self.state = 231 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,28,self._ctx)

                pass
            elif token in [PathParser.BIN_INVERT]:
                self.enterOuterAlt(localctx, 11)
                self.state = 234 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 233
                        self.opBinInvert()

                    else:
                        raise NoViableAltException(self)
                    self.state = 236 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,29,self._ctx)

                pass
            elif token in [PathParser.IRG_SGN1]:
                self.enterOuterAlt(localctx, 12)
                self.state = 239 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 238
                        self.c_irg1()

                    else:
                        raise NoViableAltException(self)
                    self.state = 241 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,30,self._ctx)

                pass
            elif token in [PathParser.LT_SGN]:
                self.enterOuterAlt(localctx, 13)
                self.state = 244 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 243
                        self.opLt()

                    else:
                        raise NoViableAltException(self)
                    self.state = 246 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,31,self._ctx)

                pass
            elif token in [PathParser.GT_SGN]:
                self.enterOuterAlt(localctx, 14)
                self.state = 249 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 248
                        self.opGt()

                    else:
                        raise NoViableAltException(self)
                    self.state = 251 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,32,self._ctx)

                pass
            elif token in [PathParser.QUOTE]:
                self.enterOuterAlt(localctx, 15)
                self.state = 254 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 253
                        self.quote()

                    else:
                        raise NoViableAltException(self)
                    self.state = 256 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,33,self._ctx)

                pass
            elif token in [PathParser.DQUOTE]:
                self.enterOuterAlt(localctx, 16)
                self.state = 259 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 258
                        self.dquote()

                    else:
                        raise NoViableAltException(self)
                    self.state = 261 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,34,self._ctx)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LdseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LET_DIG_S_LET(self):
            return self.getToken(PathParser.LET_DIG_S_LET, 0)

        def getRuleIndex(self):
            return PathParser.RULE_ldse

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLdse" ):
                listener.enterLdse(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLdse" ):
                listener.exitLdse(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLdse" ):
                return visitor.visitLdse(self)
            else:
                return visitor.visitChildren(self)




    def ldse(self):

        localctx = PathParser.LdseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_ldse)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 265
            self.match(PathParser.LET_DIG_S_LET)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OpNotContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXCAM_SGN(self):
            return self.getToken(PathParser.EXCAM_SGN, 0)

        def getRuleIndex(self):
            return PathParser.RULE_opNot

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpNot" ):
                listener.enterOpNot(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpNot" ):
                listener.exitOpNot(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOpNot" ):
                return visitor.visitOpNot(self)
            else:
                return visitor.visitChildren(self)




    def opNot(self):

        localctx = PathParser.OpNotContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_opNot)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 267
            self.match(PathParser.EXCAM_SGN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OpBinInvertContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BIN_INVERT(self):
            return self.getToken(PathParser.BIN_INVERT, 0)

        def getRuleIndex(self):
            return PathParser.RULE_opBinInvert

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpBinInvert" ):
                listener.enterOpBinInvert(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpBinInvert" ):
                listener.exitOpBinInvert(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOpBinInvert" ):
                return visitor.visitOpBinInvert(self)
            else:
                return visitor.visitChildren(self)




    def opBinInvert(self):

        localctx = PathParser.OpBinInvertContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_opBinInvert)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 269
            self.match(PathParser.BIN_INVERT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OpEqualContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQ(self):
            return self.getToken(PathParser.EQ, 0)

        def getRuleIndex(self):
            return PathParser.RULE_opEqual

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpEqual" ):
                listener.enterOpEqual(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpEqual" ):
                listener.exitOpEqual(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOpEqual" ):
                return visitor.visitOpEqual(self)
            else:
                return visitor.visitChildren(self)




    def opEqual(self):

        localctx = PathParser.OpEqualContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_opEqual)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 271
            self.match(PathParser.EQ)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OpLtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LT_SGN(self):
            return self.getToken(PathParser.LT_SGN, 0)

        def getRuleIndex(self):
            return PathParser.RULE_opLt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpLt" ):
                listener.enterOpLt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpLt" ):
                listener.exitOpLt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOpLt" ):
                return visitor.visitOpLt(self)
            else:
                return visitor.visitChildren(self)




    def opLt(self):

        localctx = PathParser.OpLtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_opLt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 273
            self.match(PathParser.LT_SGN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OpGtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GT_SGN(self):
            return self.getToken(PathParser.GT_SGN, 0)

        def getRuleIndex(self):
            return PathParser.RULE_opGt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpGt" ):
                listener.enterOpGt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpGt" ):
                listener.exitOpGt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOpGt" ):
                return visitor.visitOpGt(self)
            else:
                return visitor.visitChildren(self)




    def opGt(self):

        localctx = PathParser.OpGtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_opGt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 275
            self.match(PathParser.GT_SGN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OpMinusContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HYPHEN(self):
            return self.getToken(PathParser.HYPHEN, 0)

        def getRuleIndex(self):
            return PathParser.RULE_opMinus

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpMinus" ):
                listener.enterOpMinus(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpMinus" ):
                listener.exitOpMinus(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOpMinus" ):
                return visitor.visitOpMinus(self)
            else:
                return visitor.visitChildren(self)




    def opMinus(self):

        localctx = PathParser.OpMinusContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_opMinus)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 277
            self.match(PathParser.HYPHEN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OpSemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SEMI_COLON(self):
            return self.getToken(PathParser.SEMI_COLON, 0)

        def getRuleIndex(self):
            return PathParser.RULE_opSem

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpSem" ):
                listener.enterOpSem(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpSem" ):
                listener.exitOpSem(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOpSem" ):
                return visitor.visitOpSem(self)
            else:
                return visitor.visitChildren(self)




    def opSem(self):

        localctx = PathParser.OpSemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_opSem)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 279
            self.match(PathParser.SEMI_COLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HASHTAG(self):
            return self.getToken(PathParser.HASHTAG, 0)

        def ddash(self):
            return self.getTypedRuleContext(PathParser.DdashContext,0)


        def WS(self):
            return self.getToken(PathParser.WS, 0)

        def getRuleIndex(self):
            return PathParser.RULE_cmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCmt" ):
                listener.enterCmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCmt" ):
                listener.exitCmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCmt" ):
                return visitor.visitCmt(self)
            else:
                return visitor.visitChildren(self)




    def cmt(self):

        localctx = PathParser.CmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_cmt)
        try:
            self.state = 285
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PathParser.HASHTAG]:
                self.enterOuterAlt(localctx, 1)
                self.state = 281
                self.match(PathParser.HASHTAG)
                pass
            elif token in [PathParser.HYPHEN]:
                self.enterOuterAlt(localctx, 2)
                self.state = 282
                self.ddash()
                self.state = 283
                self.match(PathParser.WS)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DdashContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opMinus(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PathParser.OpMinusContext)
            else:
                return self.getTypedRuleContext(PathParser.OpMinusContext,i)


        def getRuleIndex(self):
            return PathParser.RULE_ddash

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDdash" ):
                listener.enterDdash(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDdash" ):
                listener.exitDdash(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDdash" ):
                return visitor.visitDdash(self)
            else:
                return visitor.visitChildren(self)




    def ddash(self):

        localctx = PathParser.DdashContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_ddash)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 287
            self.opMinus()
            self.state = 288
            self.opMinus()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QuoteContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def QUOTE(self):
            return self.getToken(PathParser.QUOTE, 0)

        def getRuleIndex(self):
            return PathParser.RULE_quote

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQuote" ):
                listener.enterQuote(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQuote" ):
                listener.exitQuote(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQuote" ):
                return visitor.visitQuote(self)
            else:
                return visitor.visitChildren(self)




    def quote(self):

        localctx = PathParser.QuoteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_quote)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 290
            self.match(PathParser.QUOTE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DquoteContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DQUOTE(self):
            return self.getToken(PathParser.DQUOTE, 0)

        def getRuleIndex(self):
            return PathParser.RULE_dquote

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDquote" ):
                listener.enterDquote(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDquote" ):
                listener.exitDquote(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDquote" ):
                return visitor.visitDquote(self)
            else:
                return visitor.visitChildren(self)




    def dquote(self):

        localctx = PathParser.DquoteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_dquote)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 292
            self.match(PathParser.DQUOTE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Us_sgnContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def US(self):
            return self.getToken(PathParser.US, 0)

        def getRuleIndex(self):
            return PathParser.RULE_us_sgn

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUs_sgn" ):
                listener.enterUs_sgn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUs_sgn" ):
                listener.exitUs_sgn(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUs_sgn" ):
                return visitor.visitUs_sgn(self)
            else:
                return visitor.visitChildren(self)




    def us_sgn(self):

        localctx = PathParser.Us_sgnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_us_sgn)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 294
            self.match(PathParser.US)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class C_andContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CH_AND(self):
            return self.getToken(PathParser.CH_AND, 0)

        def getRuleIndex(self):
            return PathParser.RULE_c_and

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterC_and" ):
                listener.enterC_and(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitC_and" ):
                listener.exitC_and(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitC_and" ):
                return visitor.visitC_and(self)
            else:
                return visitor.visitChildren(self)




    def c_and(self):

        localctx = PathParser.C_andContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_c_and)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 296
            self.match(PathParser.CH_AND)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class C_orContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CH_OR(self):
            return self.getToken(PathParser.CH_OR, 0)

        def getRuleIndex(self):
            return PathParser.RULE_c_or

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterC_or" ):
                listener.enterC_or(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitC_or" ):
                listener.exitC_or(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitC_or" ):
                return visitor.visitC_or(self)
            else:
                return visitor.visitChildren(self)




    def c_or(self):

        localctx = PathParser.C_orContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_c_or)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 298
            self.match(PathParser.CH_OR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class C_slashContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SLASH(self):
            return self.getToken(PathParser.SLASH, 0)

        def getRuleIndex(self):
            return PathParser.RULE_c_slash

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterC_slash" ):
                listener.enterC_slash(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitC_slash" ):
                listener.exitC_slash(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitC_slash" ):
                return visitor.visitC_slash(self)
            else:
                return visitor.visitChildren(self)




    def c_slash(self):

        localctx = PathParser.C_slashContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_c_slash)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 300
            self.match(PathParser.SLASH)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class C_slash_hexContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SLASH_HEX(self):
            return self.getToken(PathParser.SLASH_HEX, 0)

        def getRuleIndex(self):
            return PathParser.RULE_c_slash_hex

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterC_slash_hex" ):
                listener.enterC_slash_hex(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitC_slash_hex" ):
                listener.exitC_slash_hex(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitC_slash_hex" ):
                return visitor.visitC_slash_hex(self)
            else:
                return visitor.visitChildren(self)




    def c_slash_hex(self):

        localctx = PathParser.C_slash_hexContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_c_slash_hex)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 302
            self.match(PathParser.SLASH_HEX)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class C_dotContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DOT(self):
            return self.getToken(PathParser.DOT, 0)

        def getRuleIndex(self):
            return PathParser.RULE_c_dot

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterC_dot" ):
                listener.enterC_dot(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitC_dot" ):
                listener.exitC_dot(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitC_dot" ):
                return visitor.visitC_dot(self)
            else:
                return visitor.visitChildren(self)




    def c_dot(self):

        localctx = PathParser.C_dotContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_c_dot)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 304
            self.match(PathParser.DOT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class C_colonContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COLON(self):
            return self.getToken(PathParser.COLON, 0)

        def getRuleIndex(self):
            return PathParser.RULE_c_colon

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterC_colon" ):
                listener.enterC_colon(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitC_colon" ):
                listener.exitC_colon(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitC_colon" ):
                return visitor.visitC_colon(self)
            else:
                return visitor.visitChildren(self)




    def c_colon(self):

        localctx = PathParser.C_colonContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_c_colon)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 306
            self.match(PathParser.COLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class S_bslashContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def B_SLASH(self):
            return self.getToken(PathParser.B_SLASH, 0)

        def getRuleIndex(self):
            return PathParser.RULE_s_bslash

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterS_bslash" ):
                listener.enterS_bslash(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitS_bslash" ):
                listener.exitS_bslash(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitS_bslash" ):
                return visitor.visitS_bslash(self)
            else:
                return visitor.visitChildren(self)




    def s_bslash(self):

        localctx = PathParser.S_bslashContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_s_bslash)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 308
            self.match(PathParser.B_SLASH)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class C_qContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def QM(self):
            return self.getToken(PathParser.QM, 0)

        def getRuleIndex(self):
            return PathParser.RULE_c_q

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterC_q" ):
                listener.enterC_q(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitC_q" ):
                listener.exitC_q(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitC_q" ):
                return visitor.visitC_q(self)
            else:
                return visitor.visitChildren(self)




    def c_q(self):

        localctx = PathParser.C_qContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_c_q)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 310
            self.match(PathParser.QM)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Par_openContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PAR_O(self):
            return self.getToken(PathParser.PAR_O, 0)

        def getRuleIndex(self):
            return PathParser.RULE_par_open

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPar_open" ):
                listener.enterPar_open(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPar_open" ):
                listener.exitPar_open(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPar_open" ):
                return visitor.visitPar_open(self)
            else:
                return visitor.visitChildren(self)




    def par_open(self):

        localctx = PathParser.Par_openContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_par_open)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 312
            self.match(PathParser.PAR_O)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Par_closeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PAR_C(self):
            return self.getToken(PathParser.PAR_C, 0)

        def getRuleIndex(self):
            return PathParser.RULE_par_close

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPar_close" ):
                listener.enterPar_close(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPar_close" ):
                listener.exitPar_close(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPar_close" ):
                return visitor.visitPar_close(self)
            else:
                return visitor.visitChildren(self)




    def par_close(self):

        localctx = PathParser.Par_closeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_par_close)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 314
            self.match(PathParser.PAR_C)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class C_starContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STAR(self):
            return self.getToken(PathParser.STAR, 0)

        def getRuleIndex(self):
            return PathParser.RULE_c_star

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterC_star" ):
                listener.enterC_star(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitC_star" ):
                listener.exitC_star(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitC_star" ):
                return visitor.visitC_star(self)
            else:
                return visitor.visitChildren(self)




    def c_star(self):

        localctx = PathParser.C_starContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_c_star)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 316
            self.match(PathParser.STAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class C_percentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PERCENT(self):
            return self.getToken(PathParser.PERCENT, 0)

        def getRuleIndex(self):
            return PathParser.RULE_c_percent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterC_percent" ):
                listener.enterC_percent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitC_percent" ):
                listener.exitC_percent(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitC_percent" ):
                return visitor.visitC_percent(self)
            else:
                return visitor.visitChildren(self)




    def c_percent(self):

        localctx = PathParser.C_percentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_c_percent)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 318
            self.match(PathParser.PERCENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class C_brackContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BRACK(self):
            return self.getToken(PathParser.BRACK, 0)

        def getRuleIndex(self):
            return PathParser.RULE_c_brack

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterC_brack" ):
                listener.enterC_brack(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitC_brack" ):
                listener.exitC_brack(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitC_brack" ):
                return visitor.visitC_brack(self)
            else:
                return visitor.visitChildren(self)




    def c_brack(self):

        localctx = PathParser.C_brackContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_c_brack)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 320
            self.match(PathParser.BRACK)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class C_acoladContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ACOLAD(self):
            return self.getToken(PathParser.ACOLAD, 0)

        def getRuleIndex(self):
            return PathParser.RULE_c_acolad

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterC_acolad" ):
                listener.enterC_acolad(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitC_acolad" ):
                listener.exitC_acolad(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitC_acolad" ):
                return visitor.visitC_acolad(self)
            else:
                return visitor.visitChildren(self)




    def c_acolad(self):

        localctx = PathParser.C_acoladContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_c_acolad)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 322
            self.match(PathParser.ACOLAD)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class C_dollarContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DOLLAR(self):
            return self.getToken(PathParser.DOLLAR, 0)

        def getRuleIndex(self):
            return PathParser.RULE_c_dollar

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterC_dollar" ):
                listener.enterC_dollar(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitC_dollar" ):
                listener.exitC_dollar(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitC_dollar" ):
                return visitor.visitC_dollar(self)
            else:
                return visitor.visitChildren(self)




    def c_dollar(self):

        localctx = PathParser.C_dollarContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_c_dollar)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 324
            self.match(PathParser.DOLLAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class C_adsgnContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ADSGN(self):
            return self.getToken(PathParser.ADSGN, 0)

        def getRuleIndex(self):
            return PathParser.RULE_c_adsgn

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterC_adsgn" ):
                listener.enterC_adsgn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitC_adsgn" ):
                listener.exitC_adsgn(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitC_adsgn" ):
                return visitor.visitC_adsgn(self)
            else:
                return visitor.visitChildren(self)




    def c_adsgn(self):

        localctx = PathParser.C_adsgnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_c_adsgn)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 326
            self.match(PathParser.ADSGN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class C_irg1Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IRG_SGN1(self):
            return self.getToken(PathParser.IRG_SGN1, 0)

        def getRuleIndex(self):
            return PathParser.RULE_c_irg1

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterC_irg1" ):
                listener.enterC_irg1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitC_irg1" ):
                listener.exitC_irg1(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitC_irg1" ):
                return visitor.visitC_irg1(self)
            else:
                return visitor.visitChildren(self)




    def c_irg1(self):

        localctx = PathParser.C_irg1Context(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_c_irg1)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 328
            self.match(PathParser.IRG_SGN1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[0] = self.path_sempred
        self._predicates[1] = self.p_value_sempred
        self._predicates[2] = self.value_sempred
        self._predicates[5] = self.delim_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def path_sempred(self, localctx:PathContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 1:
                return self.precpred(self._ctx, 2)
         

    def p_value_sempred(self, localctx:P_valueContext, predIndex:int):
            if predIndex == 2:
                return self.precpred(self._ctx, 2)
         

    def value_sempred(self, localctx:ValueContext, predIndex:int):
            if predIndex == 3:
                return self.precpred(self._ctx, 3)
         

    def delim_sempred(self, localctx:DelimContext, predIndex:int):
            if predIndex == 4:
                return self.precpred(self._ctx, 3)
         




