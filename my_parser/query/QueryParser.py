# Generated from Query.g4 by ANTLR 4.9.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3%")
        buf.write("\u0165\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\4\'\t\'\3\2\3\2\3\2\3\2\3\2\3\2\3\2\5\2V\n\2\3\2\3\2")
        buf.write("\3\2\3\2\7\2\\\n\2\f\2\16\2_\13\2\3\3\3\3\3\3\3\3\3\3")
        buf.write("\3\3\3\3\3\3\3\3\3\3\3\3\5\3l\n\3\3\4\3\4\6\4p\n\4\r\4")
        buf.write("\16\4q\3\4\5\4u\n\4\3\4\3\4\3\4\6\4z\n\4\r\4\16\4{\7\4")
        buf.write("~\n\4\f\4\16\4\u0081\13\4\3\5\3\5\6\5\u0085\n\5\r\5\16")
        buf.write("\5\u0086\5\5\u0089\n\5\3\6\3\6\6\6\u008d\n\6\r\6\16\6")
        buf.write("\u008e\3\6\6\6\u0092\n\6\r\6\16\6\u0093\3\6\6\6\u0097")
        buf.write("\n\6\r\6\16\6\u0098\3\6\6\6\u009c\n\6\r\6\16\6\u009d\3")
        buf.write("\6\3\6\6\6\u00a2\n\6\r\6\16\6\u00a3\3\6\6\6\u00a7\n\6")
        buf.write("\r\6\16\6\u00a8\3\6\6\6\u00ac\n\6\r\6\16\6\u00ad\3\6\6")
        buf.write("\6\u00b1\n\6\r\6\16\6\u00b2\3\6\6\6\u00b6\n\6\r\6\16\6")
        buf.write("\u00b7\3\6\6\6\u00bb\n\6\r\6\16\6\u00bc\3\6\6\6\u00c0")
        buf.write("\n\6\r\6\16\6\u00c1\5\6\u00c4\n\6\3\7\3\7\5\7\u00c8\n")
        buf.write("\7\3\b\3\b\3\b\3\b\3\b\3\b\5\b\u00d0\n\b\3\t\6\t\u00d3")
        buf.write("\n\t\r\t\16\t\u00d4\3\t\6\t\u00d8\n\t\r\t\16\t\u00d9\3")
        buf.write("\t\6\t\u00dd\n\t\r\t\16\t\u00de\3\t\6\t\u00e2\n\t\r\t")
        buf.write("\16\t\u00e3\3\t\6\t\u00e7\n\t\r\t\16\t\u00e8\3\t\6\t\u00ec")
        buf.write("\n\t\r\t\16\t\u00ed\3\t\6\t\u00f1\n\t\r\t\16\t\u00f2\3")
        buf.write("\t\6\t\u00f6\n\t\r\t\16\t\u00f7\3\t\6\t\u00fb\n\t\r\t")
        buf.write("\16\t\u00fc\3\t\6\t\u0100\n\t\r\t\16\t\u0101\3\t\6\t\u0105")
        buf.write("\n\t\r\t\16\t\u0106\3\t\6\t\u010a\n\t\r\t\16\t\u010b\3")
        buf.write("\t\6\t\u010f\n\t\r\t\16\t\u0110\3\t\6\t\u0114\n\t\r\t")
        buf.write("\16\t\u0115\3\t\6\t\u0119\n\t\r\t\16\t\u011a\3\t\6\t\u011e")
        buf.write("\n\t\r\t\16\t\u011f\5\t\u0122\n\t\3\n\3\n\3\13\3\13\3")
        buf.write("\f\3\f\3\r\3\r\3\16\3\16\3\17\3\17\3\20\3\20\3\21\3\21")
        buf.write("\3\22\3\22\3\22\3\22\5\22\u0138\n\22\3\23\3\23\3\23\3")
        buf.write("\24\3\24\3\25\3\25\3\26\3\26\3\27\3\27\3\30\3\30\3\31")
        buf.write("\3\31\3\32\3\32\3\33\3\33\3\34\3\34\3\35\3\35\3\36\3\36")
        buf.write("\3\37\3\37\3 \3 \3!\3!\3\"\3\"\3#\3#\3$\3$\3%\3%\3&\3")
        buf.write("&\3\'\3\'\3\'\2\4\2\6(\2\4\6\b\n\f\16\20\22\24\26\30\32")
        buf.write("\34\36 \"$&(*,.\60\62\64\668:<>@BDFHJL\2\2\2\u0186\2U")
        buf.write("\3\2\2\2\4k\3\2\2\2\6t\3\2\2\2\b\u0088\3\2\2\2\n\u00c3")
        buf.write("\3\2\2\2\f\u00c7\3\2\2\2\16\u00cf\3\2\2\2\20\u0121\3\2")
        buf.write("\2\2\22\u0123\3\2\2\2\24\u0125\3\2\2\2\26\u0127\3\2\2")
        buf.write("\2\30\u0129\3\2\2\2\32\u012b\3\2\2\2\34\u012d\3\2\2\2")
        buf.write("\36\u012f\3\2\2\2 \u0131\3\2\2\2\"\u0137\3\2\2\2$\u0139")
        buf.write("\3\2\2\2&\u013c\3\2\2\2(\u013e\3\2\2\2*\u0140\3\2\2\2")
        buf.write(",\u0142\3\2\2\2.\u0144\3\2\2\2\60\u0146\3\2\2\2\62\u0148")
        buf.write("\3\2\2\2\64\u014a\3\2\2\2\66\u014c\3\2\2\28\u014e\3\2")
        buf.write("\2\2:\u0150\3\2\2\2<\u0152\3\2\2\2>\u0154\3\2\2\2@\u0156")
        buf.write("\3\2\2\2B\u0158\3\2\2\2D\u015a\3\2\2\2F\u015c\3\2\2\2")
        buf.write("H\u015e\3\2\2\2J\u0160\3\2\2\2L\u0162\3\2\2\2NO\b\2\1")
        buf.write("\2OP\5\4\3\2PQ\5\30\r\2QR\5\6\4\2RV\3\2\2\2SV\5\4\3\2")
        buf.write("TV\7\2\2\3UN\3\2\2\2US\3\2\2\2UT\3\2\2\2V]\3\2\2\2WX\f")
        buf.write("\6\2\2XY\5,\27\2YZ\5\2\2\7Z\\\3\2\2\2[W\3\2\2\2\\_\3\2")
        buf.write("\2\2][\3\2\2\2]^\3\2\2\2^\3\3\2\2\2_]\3\2\2\2`a\5\22\n")
        buf.write("\2ab\5\4\3\2bl\3\2\2\2cd\5*\26\2de\5\4\3\2el\3\2\2\2f")
        buf.write("g\5\f\7\2gh\5\4\3\2hl\3\2\2\2il\5\f\7\2jl\5*\26\2k`\3")
        buf.write("\2\2\2kc\3\2\2\2kf\3\2\2\2ki\3\2\2\2kj\3\2\2\2l\5\3\2")
        buf.write("\2\2mo\b\4\1\2np\5\b\5\2on\3\2\2\2pq\3\2\2\2qo\3\2\2\2")
        buf.write("qr\3\2\2\2ru\3\2\2\2su\7\2\2\3tm\3\2\2\2ts\3\2\2\2u\177")
        buf.write("\3\2\2\2vw\f\5\2\2wy\5\16\b\2xz\5\b\5\2yx\3\2\2\2z{\3")
        buf.write("\2\2\2{y\3\2\2\2{|\3\2\2\2|~\3\2\2\2}v\3\2\2\2~\u0081")
        buf.write("\3\2\2\2\177}\3\2\2\2\177\u0080\3\2\2\2\u0080\7\3\2\2")
        buf.write("\2\u0081\177\3\2\2\2\u0082\u0089\5\f\7\2\u0083\u0085\5")
        buf.write("\n\6\2\u0084\u0083\3\2\2\2\u0085\u0086\3\2\2\2\u0086\u0084")
        buf.write("\3\2\2\2\u0086\u0087\3\2\2\2\u0087\u0089\3\2\2\2\u0088")
        buf.write("\u0082\3\2\2\2\u0088\u0084\3\2\2\2\u0089\t\3\2\2\2\u008a")
        buf.write("\u00c4\5\36\20\2\u008b\u008d\5*\26\2\u008c\u008b\3\2\2")
        buf.write("\2\u008d\u008e\3\2\2\2\u008e\u008c\3\2\2\2\u008e\u008f")
        buf.write("\3\2\2\2\u008f\u00c4\3\2\2\2\u0090\u0092\5\66\34\2\u0091")
        buf.write("\u0090\3\2\2\2\u0092\u0093\3\2\2\2\u0093\u0091\3\2\2\2")
        buf.write("\u0093\u0094\3\2\2\2\u0094\u00c4\3\2\2\2\u0095\u0097\5")
        buf.write("\62\32\2\u0096\u0095\3\2\2\2\u0097\u0098\3\2\2\2\u0098")
        buf.write("\u0096\3\2\2\2\u0098\u0099\3\2\2\2\u0099\u00c4\3\2\2\2")
        buf.write("\u009a\u009c\7\6\2\2\u009b\u009a\3\2\2\2\u009c\u009d\3")
        buf.write("\2\2\2\u009d\u009b\3\2\2\2\u009d\u009e\3\2\2\2\u009e\u00c4")
        buf.write("\3\2\2\2\u009f\u00c4\7\7\2\2\u00a0\u00a2\5B\"\2\u00a1")
        buf.write("\u00a0\3\2\2\2\u00a2\u00a3\3\2\2\2\u00a3\u00a1\3\2\2\2")
        buf.write("\u00a3\u00a4\3\2\2\2\u00a4\u00c4\3\2\2\2\u00a5\u00a7\5")
        buf.write("8\35\2\u00a6\u00a5\3\2\2\2\u00a7\u00a8\3\2\2\2\u00a8\u00a6")
        buf.write("\3\2\2\2\u00a8\u00a9\3\2\2\2\u00a9\u00c4\3\2\2\2\u00aa")
        buf.write("\u00ac\5 \21\2\u00ab\u00aa\3\2\2\2\u00ac\u00ad\3\2\2\2")
        buf.write("\u00ad\u00ab\3\2\2\2\u00ad\u00ae\3\2\2\2\u00ae\u00c4\3")
        buf.write("\2\2\2\u00af\u00b1\5:\36\2\u00b0\u00af\3\2\2\2\u00b1\u00b2")
        buf.write("\3\2\2\2\u00b2\u00b0\3\2\2\2\u00b2\u00b3\3\2\2\2\u00b3")
        buf.write("\u00c4\3\2\2\2\u00b4\u00b6\5\30\r\2\u00b5\u00b4\3\2\2")
        buf.write("\2\u00b6\u00b7\3\2\2\2\u00b7\u00b5\3\2\2\2\u00b7\u00b8")
        buf.write("\3\2\2\2\u00b8\u00c4\3\2\2\2\u00b9\u00bb\5\20\t\2\u00ba")
        buf.write("\u00b9\3\2\2\2\u00bb\u00bc\3\2\2\2\u00bc\u00ba\3\2\2\2")
        buf.write("\u00bc\u00bd\3\2\2\2\u00bd\u00c4\3\2\2\2\u00be\u00c0\5")
        buf.write("\64\33\2\u00bf\u00be\3\2\2\2\u00c0\u00c1\3\2\2\2\u00c1")
        buf.write("\u00bf\3\2\2\2\u00c1\u00c2\3\2\2\2\u00c2\u00c4\3\2\2\2")
        buf.write("\u00c3\u008a\3\2\2\2\u00c3\u008c\3\2\2\2\u00c3\u0091\3")
        buf.write("\2\2\2\u00c3\u0096\3\2\2\2\u00c3\u009b\3\2\2\2\u00c3\u009f")
        buf.write("\3\2\2\2\u00c3\u00a1\3\2\2\2\u00c3\u00a6\3\2\2\2\u00c3")
        buf.write("\u00ab\3\2\2\2\u00c3\u00b0\3\2\2\2\u00c3\u00b5\3\2\2\2")
        buf.write("\u00c3\u00ba\3\2\2\2\u00c3\u00bf\3\2\2\2\u00c4\13\3\2")
        buf.write("\2\2\u00c5\u00c8\5\22\n\2\u00c6\u00c8\7\4\2\2\u00c7\u00c5")
        buf.write("\3\2\2\2\u00c7\u00c6\3\2\2\2\u00c8\r\3\2\2\2\u00c9\u00ca")
        buf.write("\7\6\2\2\u00ca\u00d0\5\16\b\2\u00cb\u00cc\7\7\2\2\u00cc")
        buf.write("\u00d0\5\16\b\2\u00cd\u00d0\7\6\2\2\u00ce\u00d0\7\7\2")
        buf.write("\2\u00cf\u00c9\3\2\2\2\u00cf\u00cb\3\2\2\2\u00cf\u00cd")
        buf.write("\3\2\2\2\u00cf\u00ce\3\2\2\2\u00d0\17\3\2\2\2\u00d1\u00d3")
        buf.write("\5@!\2\u00d2\u00d1\3\2\2\2\u00d3\u00d4\3\2\2\2\u00d4\u00d2")
        buf.write("\3\2\2\2\u00d4\u00d5\3\2\2\2\u00d5\u0122\3\2\2\2\u00d6")
        buf.write("\u00d8\5> \2\u00d7\u00d6\3\2\2\2\u00d8\u00d9\3\2\2\2\u00d9")
        buf.write("\u00d7\3\2\2\2\u00d9\u00da\3\2\2\2\u00da\u0122\3\2\2\2")
        buf.write("\u00db\u00dd\5<\37\2\u00dc\u00db\3\2\2\2\u00dd\u00de\3")
        buf.write("\2\2\2\u00de\u00dc\3\2\2\2\u00de\u00df\3\2\2\2\u00df\u0122")
        buf.write("\3\2\2\2\u00e0\u00e2\5D#\2\u00e1\u00e0\3\2\2\2\u00e2\u00e3")
        buf.write("\3\2\2\2\u00e3\u00e1\3\2\2\2\u00e3\u00e4\3\2\2\2\u00e4")
        buf.write("\u0122\3\2\2\2\u00e5\u00e7\5F$\2\u00e6\u00e5\3\2\2\2\u00e7")
        buf.write("\u00e8\3\2\2\2\u00e8\u00e6\3\2\2\2\u00e8\u00e9\3\2\2\2")
        buf.write("\u00e9\u0122\3\2\2\2\u00ea\u00ec\5H%\2\u00eb\u00ea\3\2")
        buf.write("\2\2\u00ec\u00ed\3\2\2\2\u00ed\u00eb\3\2\2\2\u00ed\u00ee")
        buf.write("\3\2\2\2\u00ee\u0122\3\2\2\2\u00ef\u00f1\5.\30\2\u00f0")
        buf.write("\u00ef\3\2\2\2\u00f1\u00f2\3\2\2\2\u00f2\u00f0\3\2\2\2")
        buf.write("\u00f2\u00f3\3\2\2\2\u00f3\u0122\3\2\2\2\u00f4\u00f6\5")
        buf.write("J&\2\u00f5\u00f4\3\2\2\2\u00f6\u00f7\3\2\2\2\u00f7\u00f5")
        buf.write("\3\2\2\2\u00f7\u00f8\3\2\2\2\u00f8\u0122\3\2\2\2\u00f9")
        buf.write("\u00fb\5\24\13\2\u00fa\u00f9\3\2\2\2\u00fb\u00fc\3\2\2")
        buf.write("\2\u00fc\u00fa\3\2\2\2\u00fc\u00fd\3\2\2\2\u00fd\u0122")
        buf.write("\3\2\2\2\u00fe\u0100\5\60\31\2\u00ff\u00fe\3\2\2\2\u0100")
        buf.write("\u0101\3\2\2\2\u0101\u00ff\3\2\2\2\u0101\u0102\3\2\2\2")
        buf.write("\u0102\u0122\3\2\2\2\u0103\u0105\5\26\f\2\u0104\u0103")
        buf.write("\3\2\2\2\u0105\u0106\3\2\2\2\u0106\u0104\3\2\2\2\u0106")
        buf.write("\u0107\3\2\2\2\u0107\u0122\3\2\2\2\u0108\u010a\5L\'\2")
        buf.write("\u0109\u0108\3\2\2\2\u010a\u010b\3\2\2\2\u010b\u0109\3")
        buf.write("\2\2\2\u010b\u010c\3\2\2\2\u010c\u0122\3\2\2\2\u010d\u010f")
        buf.write("\5\32\16\2\u010e\u010d\3\2\2\2\u010f\u0110\3\2\2\2\u0110")
        buf.write("\u010e\3\2\2\2\u0110\u0111\3\2\2\2\u0111\u0122\3\2\2\2")
        buf.write("\u0112\u0114\5\34\17\2\u0113\u0112\3\2\2\2\u0114\u0115")
        buf.write("\3\2\2\2\u0115\u0113\3\2\2\2\u0115\u0116\3\2\2\2\u0116")
        buf.write("\u0122\3\2\2\2\u0117\u0119\5&\24\2\u0118\u0117\3\2\2\2")
        buf.write("\u0119\u011a\3\2\2\2\u011a\u0118\3\2\2\2\u011a\u011b\3")
        buf.write("\2\2\2\u011b\u0122\3\2\2\2\u011c\u011e\5(\25\2\u011d\u011c")
        buf.write("\3\2\2\2\u011e\u011f\3\2\2\2\u011f\u011d\3\2\2\2\u011f")
        buf.write("\u0120\3\2\2\2\u0120\u0122\3\2\2\2\u0121\u00d2\3\2\2\2")
        buf.write("\u0121\u00d7\3\2\2\2\u0121\u00dc\3\2\2\2\u0121\u00e1\3")
        buf.write("\2\2\2\u0121\u00e6\3\2\2\2\u0121\u00eb\3\2\2\2\u0121\u00f0")
        buf.write("\3\2\2\2\u0121\u00f5\3\2\2\2\u0121\u00fa\3\2\2\2\u0121")
        buf.write("\u00ff\3\2\2\2\u0121\u0104\3\2\2\2\u0121\u0109\3\2\2\2")
        buf.write("\u0121\u010e\3\2\2\2\u0121\u0113\3\2\2\2\u0121\u0118\3")
        buf.write("\2\2\2\u0121\u011d\3\2\2\2\u0122\21\3\2\2\2\u0123\u0124")
        buf.write("\7\3\2\2\u0124\23\3\2\2\2\u0125\u0126\7\36\2\2\u0126\25")
        buf.write("\3\2\2\2\u0127\u0128\7\37\2\2\u0128\27\3\2\2\2\u0129\u012a")
        buf.write("\7\16\2\2\u012a\31\3\2\2\2\u012b\u012c\7\"\2\2\u012c\33")
        buf.write("\3\2\2\2\u012d\u012e\7#\2\2\u012e\35\3\2\2\2\u012f\u0130")
        buf.write("\7\f\2\2\u0130\37\3\2\2\2\u0131\u0132\7\26\2\2\u0132!")
        buf.write("\3\2\2\2\u0133\u0138\7%\2\2\u0134\u0135\5$\23\2\u0135")
        buf.write("\u0136\7\6\2\2\u0136\u0138\3\2\2\2\u0137\u0133\3\2\2\2")
        buf.write("\u0137\u0134\3\2\2\2\u0138#\3\2\2\2\u0139\u013a\5\36\20")
        buf.write("\2\u013a\u013b\5\36\20\2\u013b%\3\2\2\2\u013c\u013d\7")
        buf.write("\n\2\2\u013d\'\3\2\2\2\u013e\u013f\7\13\2\2\u013f)\3\2")
        buf.write("\2\2\u0140\u0141\7\r\2\2\u0141+\3\2\2\2\u0142\u0143\7")
        buf.write("\23\2\2\u0143-\3\2\2\2\u0144\u0145\7\24\2\2\u0145/\3\2")
        buf.write("\2\2\u0146\u0147\7!\2\2\u0147\61\3\2\2\2\u0148\u0149\7")
        buf.write("\5\2\2\u0149\63\3\2\2\2\u014a\u014b\7\17\2\2\u014b\65")
        buf.write("\3\2\2\2\u014c\u014d\7\25\2\2\u014d\67\3\2\2\2\u014e\u014f")
        buf.write("\7\20\2\2\u014f9\3\2\2\2\u0150\u0151\7\21\2\2\u0151;\3")
        buf.write("\2\2\2\u0152\u0153\7\30\2\2\u0153=\3\2\2\2\u0154\u0155")
        buf.write("\7\31\2\2\u0155?\3\2\2\2\u0156\u0157\7\27\2\2\u0157A\3")
        buf.write("\2\2\2\u0158\u0159\7\22\2\2\u0159C\3\2\2\2\u015a\u015b")
        buf.write("\7\32\2\2\u015bE\3\2\2\2\u015c\u015d\7\33\2\2\u015dG\3")
        buf.write("\2\2\2\u015e\u015f\7\34\2\2\u015fI\3\2\2\2\u0160\u0161")
        buf.write("\7\35\2\2\u0161K\3\2\2\2\u0162\u0163\7 \2\2\u0163M\3\2")
        buf.write("\2\2+U]kqt{\177\u0086\u0088\u008e\u0093\u0098\u009d\u00a3")
        buf.write("\u00a8\u00ad\u00b2\u00b7\u00bc\u00c1\u00c3\u00c7\u00cf")
        buf.write("\u00d4\u00d9\u00de\u00e3\u00e8\u00ed\u00f2\u00f7\u00fc")
        buf.write("\u0101\u0106\u010b\u0110\u0115\u011a\u011f\u0121\u0137")
        return buf.getvalue()


class QueryParser ( Parser ):

    grammarFileName = "Query.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "'&'", "'%26'", "<INVALID>", "<INVALID>", 
                     "'*'", "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "'~'", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "'#'" ]

    symbolicNames = [ "<INVALID>", "LET_DIG_S_LET", "LET_DIG", "SLASH", 
                      "WS", "CAMMA", "DIGIT", "LETTER", "QUOTE", "DQUOTE", 
                      "HYPHEN", "US", "EQ", "DOT", "B_SLASH", "QM", "PERCENT", 
                      "CH_AND", "CH_AND_HEX", "COLON", "SEMI_COLON", "STAR", 
                      "PAR_O", "PAR_C", "BRACK", "ACOLAD", "DOLLAR", "ADSGN", 
                      "EXCAM_SGN", "BIN_INVERT", "IRG_SGN1", "CH_OR", "LT_SGN", 
                      "GT_SGN", "HASTAG", "HASHTAG" ]

    RULE_query = 0
    RULE_p_id = 1
    RULE_q_value = 2
    RULE_value = 3
    RULE_ilg = 4
    RULE_label = 5
    RULE_delim = 6
    RULE_ch_ilg = 7
    RULE_ldse = 8
    RULE_opNot = 9
    RULE_opBinInvert = 10
    RULE_opEqual = 11
    RULE_opLt = 12
    RULE_opGt = 13
    RULE_opMinus = 14
    RULE_opSem = 15
    RULE_cmt = 16
    RULE_ddash = 17
    RULE_quote = 18
    RULE_dquote = 19
    RULE_us_sgn = 20
    RULE_c_and = 21
    RULE_c_and_hex = 22
    RULE_c_or = 23
    RULE_c_slash = 24
    RULE_c_dot = 25
    RULE_c_colon = 26
    RULE_s_bslash = 27
    RULE_c_q = 28
    RULE_par_open = 29
    RULE_par_close = 30
    RULE_c_star = 31
    RULE_c_percent = 32
    RULE_c_brack = 33
    RULE_c_acolad = 34
    RULE_c_dollar = 35
    RULE_c_adsgn = 36
    RULE_c_irg1 = 37

    ruleNames =  [ "query", "p_id", "q_value", "value", "ilg", "label", 
                   "delim", "ch_ilg", "ldse", "opNot", "opBinInvert", "opEqual", 
                   "opLt", "opGt", "opMinus", "opSem", "cmt", "ddash", "quote", 
                   "dquote", "us_sgn", "c_and", "c_and_hex", "c_or", "c_slash", 
                   "c_dot", "c_colon", "s_bslash", "c_q", "par_open", "par_close", 
                   "c_star", "c_percent", "c_brack", "c_acolad", "c_dollar", 
                   "c_adsgn", "c_irg1" ]

    EOF = Token.EOF
    LET_DIG_S_LET=1
    LET_DIG=2
    SLASH=3
    WS=4
    CAMMA=5
    DIGIT=6
    LETTER=7
    QUOTE=8
    DQUOTE=9
    HYPHEN=10
    US=11
    EQ=12
    DOT=13
    B_SLASH=14
    QM=15
    PERCENT=16
    CH_AND=17
    CH_AND_HEX=18
    COLON=19
    SEMI_COLON=20
    STAR=21
    PAR_O=22
    PAR_C=23
    BRACK=24
    ACOLAD=25
    DOLLAR=26
    ADSGN=27
    EXCAM_SGN=28
    BIN_INVERT=29
    IRG_SGN1=30
    CH_OR=31
    LT_SGN=32
    GT_SGN=33
    HASTAG=34
    HASHTAG=35

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class QueryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def p_id(self):
            return self.getTypedRuleContext(QueryParser.P_idContext,0)


        def opEqual(self):
            return self.getTypedRuleContext(QueryParser.OpEqualContext,0)


        def q_value(self):
            return self.getTypedRuleContext(QueryParser.Q_valueContext,0)


        def EOF(self):
            return self.getToken(QueryParser.EOF, 0)

        def query(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QueryParser.QueryContext)
            else:
                return self.getTypedRuleContext(QueryParser.QueryContext,i)


        def c_and(self):
            return self.getTypedRuleContext(QueryParser.C_andContext,0)


        def getRuleIndex(self):
            return QueryParser.RULE_query

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQuery" ):
                listener.enterQuery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQuery" ):
                listener.exitQuery(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQuery" ):
                return visitor.visitQuery(self)
            else:
                return visitor.visitChildren(self)



    def query(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = QueryParser.QueryContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 0
        self.enterRecursionRule(localctx, 0, self.RULE_query, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 83
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,0,self._ctx)
            if la_ == 1:
                self.state = 77
                self.p_id()
                self.state = 78
                self.opEqual()
                self.state = 79
                self.q_value(0)
                pass

            elif la_ == 2:
                self.state = 81
                self.p_id()
                pass

            elif la_ == 3:
                self.state = 82
                self.match(QueryParser.EOF)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 91
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,1,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = QueryParser.QueryContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_query)
                    self.state = 85
                    if not self.precpred(self._ctx, 4):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 4)")
                    self.state = 86
                    self.c_and()
                    self.state = 87
                    self.query(5) 
                self.state = 93
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,1,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class P_idContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ldse(self):
            return self.getTypedRuleContext(QueryParser.LdseContext,0)


        def p_id(self):
            return self.getTypedRuleContext(QueryParser.P_idContext,0)


        def us_sgn(self):
            return self.getTypedRuleContext(QueryParser.Us_sgnContext,0)


        def label(self):
            return self.getTypedRuleContext(QueryParser.LabelContext,0)


        def getRuleIndex(self):
            return QueryParser.RULE_p_id

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterP_id" ):
                listener.enterP_id(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitP_id" ):
                listener.exitP_id(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitP_id" ):
                return visitor.visitP_id(self)
            else:
                return visitor.visitChildren(self)




    def p_id(self):

        localctx = QueryParser.P_idContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_p_id)
        try:
            self.state = 105
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 94
                self.ldse()
                self.state = 95
                self.p_id()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 97
                self.us_sgn()
                self.state = 98
                self.p_id()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 100
                self.label()
                self.state = 101
                self.p_id()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 103
                self.label()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 104
                self.us_sgn()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Q_valueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def value(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QueryParser.ValueContext)
            else:
                return self.getTypedRuleContext(QueryParser.ValueContext,i)


        def EOF(self):
            return self.getToken(QueryParser.EOF, 0)

        def q_value(self):
            return self.getTypedRuleContext(QueryParser.Q_valueContext,0)


        def delim(self):
            return self.getTypedRuleContext(QueryParser.DelimContext,0)


        def getRuleIndex(self):
            return QueryParser.RULE_q_value

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQ_value" ):
                listener.enterQ_value(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQ_value" ):
                listener.exitQ_value(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQ_value" ):
                return visitor.visitQ_value(self)
            else:
                return visitor.visitChildren(self)



    def q_value(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = QueryParser.Q_valueContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 4
        self.enterRecursionRule(localctx, 4, self.RULE_q_value, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 114
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [QueryParser.LET_DIG_S_LET, QueryParser.LET_DIG, QueryParser.SLASH, QueryParser.WS, QueryParser.CAMMA, QueryParser.QUOTE, QueryParser.DQUOTE, QueryParser.HYPHEN, QueryParser.US, QueryParser.EQ, QueryParser.DOT, QueryParser.B_SLASH, QueryParser.QM, QueryParser.PERCENT, QueryParser.CH_AND_HEX, QueryParser.COLON, QueryParser.SEMI_COLON, QueryParser.STAR, QueryParser.PAR_O, QueryParser.PAR_C, QueryParser.BRACK, QueryParser.ACOLAD, QueryParser.DOLLAR, QueryParser.ADSGN, QueryParser.EXCAM_SGN, QueryParser.BIN_INVERT, QueryParser.IRG_SGN1, QueryParser.CH_OR, QueryParser.LT_SGN, QueryParser.GT_SGN]:
                self.state = 109 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 108
                        self.value()

                    else:
                        raise NoViableAltException(self)
                    self.state = 111 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,3,self._ctx)

                pass
            elif token in [QueryParser.EOF]:
                self.state = 113
                self.match(QueryParser.EOF)
                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 125
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,6,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = QueryParser.Q_valueContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_q_value)
                    self.state = 116
                    if not self.precpred(self._ctx, 3):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                    self.state = 117
                    self.delim()
                    self.state = 119 
                    self._errHandler.sync(self)
                    _alt = 1
                    while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt == 1:
                            self.state = 118
                            self.value()

                        else:
                            raise NoViableAltException(self)
                        self.state = 121 
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,5,self._ctx)
             
                self.state = 127
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,6,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class ValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def label(self):
            return self.getTypedRuleContext(QueryParser.LabelContext,0)


        def ilg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QueryParser.IlgContext)
            else:
                return self.getTypedRuleContext(QueryParser.IlgContext,i)


        def getRuleIndex(self):
            return QueryParser.RULE_value

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterValue" ):
                listener.enterValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitValue" ):
                listener.exitValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitValue" ):
                return visitor.visitValue(self)
            else:
                return visitor.visitChildren(self)




    def value(self):

        localctx = QueryParser.ValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_value)
        try:
            self.state = 134
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [QueryParser.LET_DIG_S_LET, QueryParser.LET_DIG]:
                self.enterOuterAlt(localctx, 1)
                self.state = 128
                self.label()
                pass
            elif token in [QueryParser.SLASH, QueryParser.WS, QueryParser.CAMMA, QueryParser.QUOTE, QueryParser.DQUOTE, QueryParser.HYPHEN, QueryParser.US, QueryParser.EQ, QueryParser.DOT, QueryParser.B_SLASH, QueryParser.QM, QueryParser.PERCENT, QueryParser.CH_AND_HEX, QueryParser.COLON, QueryParser.SEMI_COLON, QueryParser.STAR, QueryParser.PAR_O, QueryParser.PAR_C, QueryParser.BRACK, QueryParser.ACOLAD, QueryParser.DOLLAR, QueryParser.ADSGN, QueryParser.EXCAM_SGN, QueryParser.BIN_INVERT, QueryParser.IRG_SGN1, QueryParser.CH_OR, QueryParser.LT_SGN, QueryParser.GT_SGN]:
                self.enterOuterAlt(localctx, 2)
                self.state = 130 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 129
                        self.ilg()

                    else:
                        raise NoViableAltException(self)
                    self.state = 132 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,7,self._ctx)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IlgContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opMinus(self):
            return self.getTypedRuleContext(QueryParser.OpMinusContext,0)


        def us_sgn(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QueryParser.Us_sgnContext)
            else:
                return self.getTypedRuleContext(QueryParser.Us_sgnContext,i)


        def c_colon(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QueryParser.C_colonContext)
            else:
                return self.getTypedRuleContext(QueryParser.C_colonContext,i)


        def c_slash(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QueryParser.C_slashContext)
            else:
                return self.getTypedRuleContext(QueryParser.C_slashContext,i)


        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(QueryParser.WS)
            else:
                return self.getToken(QueryParser.WS, i)

        def CAMMA(self):
            return self.getToken(QueryParser.CAMMA, 0)

        def c_percent(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QueryParser.C_percentContext)
            else:
                return self.getTypedRuleContext(QueryParser.C_percentContext,i)


        def s_bslash(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QueryParser.S_bslashContext)
            else:
                return self.getTypedRuleContext(QueryParser.S_bslashContext,i)


        def opSem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QueryParser.OpSemContext)
            else:
                return self.getTypedRuleContext(QueryParser.OpSemContext,i)


        def c_q(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QueryParser.C_qContext)
            else:
                return self.getTypedRuleContext(QueryParser.C_qContext,i)


        def opEqual(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QueryParser.OpEqualContext)
            else:
                return self.getTypedRuleContext(QueryParser.OpEqualContext,i)


        def ch_ilg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QueryParser.Ch_ilgContext)
            else:
                return self.getTypedRuleContext(QueryParser.Ch_ilgContext,i)


        def c_dot(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QueryParser.C_dotContext)
            else:
                return self.getTypedRuleContext(QueryParser.C_dotContext,i)


        def getRuleIndex(self):
            return QueryParser.RULE_ilg

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIlg" ):
                listener.enterIlg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIlg" ):
                listener.exitIlg(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIlg" ):
                return visitor.visitIlg(self)
            else:
                return visitor.visitChildren(self)




    def ilg(self):

        localctx = QueryParser.IlgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_ilg)
        try:
            self.state = 193
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [QueryParser.HYPHEN]:
                self.enterOuterAlt(localctx, 1)
                self.state = 136
                self.opMinus()
                pass
            elif token in [QueryParser.US]:
                self.enterOuterAlt(localctx, 2)
                self.state = 138 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 137
                        self.us_sgn()

                    else:
                        raise NoViableAltException(self)
                    self.state = 140 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,9,self._ctx)

                pass
            elif token in [QueryParser.COLON]:
                self.enterOuterAlt(localctx, 3)
                self.state = 143 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 142
                        self.c_colon()

                    else:
                        raise NoViableAltException(self)
                    self.state = 145 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,10,self._ctx)

                pass
            elif token in [QueryParser.SLASH]:
                self.enterOuterAlt(localctx, 4)
                self.state = 148 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 147
                        self.c_slash()

                    else:
                        raise NoViableAltException(self)
                    self.state = 150 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,11,self._ctx)

                pass
            elif token in [QueryParser.WS]:
                self.enterOuterAlt(localctx, 5)
                self.state = 153 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 152
                        self.match(QueryParser.WS)

                    else:
                        raise NoViableAltException(self)
                    self.state = 155 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,12,self._ctx)

                pass
            elif token in [QueryParser.CAMMA]:
                self.enterOuterAlt(localctx, 6)
                self.state = 157
                self.match(QueryParser.CAMMA)
                pass
            elif token in [QueryParser.PERCENT]:
                self.enterOuterAlt(localctx, 7)
                self.state = 159 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 158
                        self.c_percent()

                    else:
                        raise NoViableAltException(self)
                    self.state = 161 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,13,self._ctx)

                pass
            elif token in [QueryParser.B_SLASH]:
                self.enterOuterAlt(localctx, 8)
                self.state = 164 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 163
                        self.s_bslash()

                    else:
                        raise NoViableAltException(self)
                    self.state = 166 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,14,self._ctx)

                pass
            elif token in [QueryParser.SEMI_COLON]:
                self.enterOuterAlt(localctx, 9)
                self.state = 169 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 168
                        self.opSem()

                    else:
                        raise NoViableAltException(self)
                    self.state = 171 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,15,self._ctx)

                pass
            elif token in [QueryParser.QM]:
                self.enterOuterAlt(localctx, 10)
                self.state = 174 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 173
                        self.c_q()

                    else:
                        raise NoViableAltException(self)
                    self.state = 176 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,16,self._ctx)

                pass
            elif token in [QueryParser.EQ]:
                self.enterOuterAlt(localctx, 11)
                self.state = 179 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 178
                        self.opEqual()

                    else:
                        raise NoViableAltException(self)
                    self.state = 181 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,17,self._ctx)

                pass
            elif token in [QueryParser.QUOTE, QueryParser.DQUOTE, QueryParser.CH_AND_HEX, QueryParser.STAR, QueryParser.PAR_O, QueryParser.PAR_C, QueryParser.BRACK, QueryParser.ACOLAD, QueryParser.DOLLAR, QueryParser.ADSGN, QueryParser.EXCAM_SGN, QueryParser.BIN_INVERT, QueryParser.IRG_SGN1, QueryParser.CH_OR, QueryParser.LT_SGN, QueryParser.GT_SGN]:
                self.enterOuterAlt(localctx, 12)
                self.state = 184 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 183
                        self.ch_ilg()

                    else:
                        raise NoViableAltException(self)
                    self.state = 186 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,18,self._ctx)

                pass
            elif token in [QueryParser.DOT]:
                self.enterOuterAlt(localctx, 13)
                self.state = 189 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 188
                        self.c_dot()

                    else:
                        raise NoViableAltException(self)
                    self.state = 191 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,19,self._ctx)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LabelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ldse(self):
            return self.getTypedRuleContext(QueryParser.LdseContext,0)


        def LET_DIG(self):
            return self.getToken(QueryParser.LET_DIG, 0)

        def getRuleIndex(self):
            return QueryParser.RULE_label

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabel" ):
                listener.enterLabel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabel" ):
                listener.exitLabel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLabel" ):
                return visitor.visitLabel(self)
            else:
                return visitor.visitChildren(self)




    def label(self):

        localctx = QueryParser.LabelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_label)
        try:
            self.state = 197
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [QueryParser.LET_DIG_S_LET]:
                self.enterOuterAlt(localctx, 1)
                self.state = 195
                self.ldse()
                pass
            elif token in [QueryParser.LET_DIG]:
                self.enterOuterAlt(localctx, 2)
                self.state = 196
                self.match(QueryParser.LET_DIG)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DelimContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WS(self):
            return self.getToken(QueryParser.WS, 0)

        def delim(self):
            return self.getTypedRuleContext(QueryParser.DelimContext,0)


        def CAMMA(self):
            return self.getToken(QueryParser.CAMMA, 0)

        def getRuleIndex(self):
            return QueryParser.RULE_delim

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDelim" ):
                listener.enterDelim(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDelim" ):
                listener.exitDelim(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDelim" ):
                return visitor.visitDelim(self)
            else:
                return visitor.visitChildren(self)




    def delim(self):

        localctx = QueryParser.DelimContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_delim)
        try:
            self.state = 205
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,22,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 199
                self.match(QueryParser.WS)
                self.state = 200
                self.delim()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 201
                self.match(QueryParser.CAMMA)
                self.state = 202
                self.delim()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 203
                self.match(QueryParser.WS)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 204
                self.match(QueryParser.CAMMA)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ch_ilgContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def c_star(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QueryParser.C_starContext)
            else:
                return self.getTypedRuleContext(QueryParser.C_starContext,i)


        def par_close(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QueryParser.Par_closeContext)
            else:
                return self.getTypedRuleContext(QueryParser.Par_closeContext,i)


        def par_open(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QueryParser.Par_openContext)
            else:
                return self.getTypedRuleContext(QueryParser.Par_openContext,i)


        def c_brack(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QueryParser.C_brackContext)
            else:
                return self.getTypedRuleContext(QueryParser.C_brackContext,i)


        def c_acolad(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QueryParser.C_acoladContext)
            else:
                return self.getTypedRuleContext(QueryParser.C_acoladContext,i)


        def c_dollar(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QueryParser.C_dollarContext)
            else:
                return self.getTypedRuleContext(QueryParser.C_dollarContext,i)


        def c_and_hex(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QueryParser.C_and_hexContext)
            else:
                return self.getTypedRuleContext(QueryParser.C_and_hexContext,i)


        def c_adsgn(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QueryParser.C_adsgnContext)
            else:
                return self.getTypedRuleContext(QueryParser.C_adsgnContext,i)


        def opNot(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QueryParser.OpNotContext)
            else:
                return self.getTypedRuleContext(QueryParser.OpNotContext,i)


        def c_or(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QueryParser.C_orContext)
            else:
                return self.getTypedRuleContext(QueryParser.C_orContext,i)


        def opBinInvert(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QueryParser.OpBinInvertContext)
            else:
                return self.getTypedRuleContext(QueryParser.OpBinInvertContext,i)


        def c_irg1(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QueryParser.C_irg1Context)
            else:
                return self.getTypedRuleContext(QueryParser.C_irg1Context,i)


        def opLt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QueryParser.OpLtContext)
            else:
                return self.getTypedRuleContext(QueryParser.OpLtContext,i)


        def opGt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QueryParser.OpGtContext)
            else:
                return self.getTypedRuleContext(QueryParser.OpGtContext,i)


        def quote(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QueryParser.QuoteContext)
            else:
                return self.getTypedRuleContext(QueryParser.QuoteContext,i)


        def dquote(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QueryParser.DquoteContext)
            else:
                return self.getTypedRuleContext(QueryParser.DquoteContext,i)


        def getRuleIndex(self):
            return QueryParser.RULE_ch_ilg

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCh_ilg" ):
                listener.enterCh_ilg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCh_ilg" ):
                listener.exitCh_ilg(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCh_ilg" ):
                return visitor.visitCh_ilg(self)
            else:
                return visitor.visitChildren(self)




    def ch_ilg(self):

        localctx = QueryParser.Ch_ilgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_ch_ilg)
        try:
            self.state = 287
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [QueryParser.STAR]:
                self.enterOuterAlt(localctx, 1)
                self.state = 208 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 207
                        self.c_star()

                    else:
                        raise NoViableAltException(self)
                    self.state = 210 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,23,self._ctx)

                pass
            elif token in [QueryParser.PAR_C]:
                self.enterOuterAlt(localctx, 2)
                self.state = 213 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 212
                        self.par_close()

                    else:
                        raise NoViableAltException(self)
                    self.state = 215 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,24,self._ctx)

                pass
            elif token in [QueryParser.PAR_O]:
                self.enterOuterAlt(localctx, 3)
                self.state = 218 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 217
                        self.par_open()

                    else:
                        raise NoViableAltException(self)
                    self.state = 220 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,25,self._ctx)

                pass
            elif token in [QueryParser.BRACK]:
                self.enterOuterAlt(localctx, 4)
                self.state = 223 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 222
                        self.c_brack()

                    else:
                        raise NoViableAltException(self)
                    self.state = 225 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,26,self._ctx)

                pass
            elif token in [QueryParser.ACOLAD]:
                self.enterOuterAlt(localctx, 5)
                self.state = 228 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 227
                        self.c_acolad()

                    else:
                        raise NoViableAltException(self)
                    self.state = 230 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,27,self._ctx)

                pass
            elif token in [QueryParser.DOLLAR]:
                self.enterOuterAlt(localctx, 6)
                self.state = 233 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 232
                        self.c_dollar()

                    else:
                        raise NoViableAltException(self)
                    self.state = 235 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,28,self._ctx)

                pass
            elif token in [QueryParser.CH_AND_HEX]:
                self.enterOuterAlt(localctx, 7)
                self.state = 238 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 237
                        self.c_and_hex()

                    else:
                        raise NoViableAltException(self)
                    self.state = 240 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,29,self._ctx)

                pass
            elif token in [QueryParser.ADSGN]:
                self.enterOuterAlt(localctx, 8)
                self.state = 243 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 242
                        self.c_adsgn()

                    else:
                        raise NoViableAltException(self)
                    self.state = 245 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,30,self._ctx)

                pass
            elif token in [QueryParser.EXCAM_SGN]:
                self.enterOuterAlt(localctx, 9)
                self.state = 248 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 247
                        self.opNot()

                    else:
                        raise NoViableAltException(self)
                    self.state = 250 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,31,self._ctx)

                pass
            elif token in [QueryParser.CH_OR]:
                self.enterOuterAlt(localctx, 10)
                self.state = 253 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 252
                        self.c_or()

                    else:
                        raise NoViableAltException(self)
                    self.state = 255 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,32,self._ctx)

                pass
            elif token in [QueryParser.BIN_INVERT]:
                self.enterOuterAlt(localctx, 11)
                self.state = 258 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 257
                        self.opBinInvert()

                    else:
                        raise NoViableAltException(self)
                    self.state = 260 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,33,self._ctx)

                pass
            elif token in [QueryParser.IRG_SGN1]:
                self.enterOuterAlt(localctx, 12)
                self.state = 263 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 262
                        self.c_irg1()

                    else:
                        raise NoViableAltException(self)
                    self.state = 265 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,34,self._ctx)

                pass
            elif token in [QueryParser.LT_SGN]:
                self.enterOuterAlt(localctx, 13)
                self.state = 268 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 267
                        self.opLt()

                    else:
                        raise NoViableAltException(self)
                    self.state = 270 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,35,self._ctx)

                pass
            elif token in [QueryParser.GT_SGN]:
                self.enterOuterAlt(localctx, 14)
                self.state = 273 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 272
                        self.opGt()

                    else:
                        raise NoViableAltException(self)
                    self.state = 275 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,36,self._ctx)

                pass
            elif token in [QueryParser.QUOTE]:
                self.enterOuterAlt(localctx, 15)
                self.state = 278 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 277
                        self.quote()

                    else:
                        raise NoViableAltException(self)
                    self.state = 280 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,37,self._ctx)

                pass
            elif token in [QueryParser.DQUOTE]:
                self.enterOuterAlt(localctx, 16)
                self.state = 283 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 282
                        self.dquote()

                    else:
                        raise NoViableAltException(self)
                    self.state = 285 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,38,self._ctx)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LdseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LET_DIG_S_LET(self):
            return self.getToken(QueryParser.LET_DIG_S_LET, 0)

        def getRuleIndex(self):
            return QueryParser.RULE_ldse

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLdse" ):
                listener.enterLdse(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLdse" ):
                listener.exitLdse(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLdse" ):
                return visitor.visitLdse(self)
            else:
                return visitor.visitChildren(self)




    def ldse(self):

        localctx = QueryParser.LdseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_ldse)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 289
            self.match(QueryParser.LET_DIG_S_LET)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OpNotContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXCAM_SGN(self):
            return self.getToken(QueryParser.EXCAM_SGN, 0)

        def getRuleIndex(self):
            return QueryParser.RULE_opNot

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpNot" ):
                listener.enterOpNot(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpNot" ):
                listener.exitOpNot(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOpNot" ):
                return visitor.visitOpNot(self)
            else:
                return visitor.visitChildren(self)




    def opNot(self):

        localctx = QueryParser.OpNotContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_opNot)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 291
            self.match(QueryParser.EXCAM_SGN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OpBinInvertContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BIN_INVERT(self):
            return self.getToken(QueryParser.BIN_INVERT, 0)

        def getRuleIndex(self):
            return QueryParser.RULE_opBinInvert

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpBinInvert" ):
                listener.enterOpBinInvert(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpBinInvert" ):
                listener.exitOpBinInvert(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOpBinInvert" ):
                return visitor.visitOpBinInvert(self)
            else:
                return visitor.visitChildren(self)




    def opBinInvert(self):

        localctx = QueryParser.OpBinInvertContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_opBinInvert)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 293
            self.match(QueryParser.BIN_INVERT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OpEqualContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQ(self):
            return self.getToken(QueryParser.EQ, 0)

        def getRuleIndex(self):
            return QueryParser.RULE_opEqual

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpEqual" ):
                listener.enterOpEqual(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpEqual" ):
                listener.exitOpEqual(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOpEqual" ):
                return visitor.visitOpEqual(self)
            else:
                return visitor.visitChildren(self)




    def opEqual(self):

        localctx = QueryParser.OpEqualContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_opEqual)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 295
            self.match(QueryParser.EQ)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OpLtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LT_SGN(self):
            return self.getToken(QueryParser.LT_SGN, 0)

        def getRuleIndex(self):
            return QueryParser.RULE_opLt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpLt" ):
                listener.enterOpLt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpLt" ):
                listener.exitOpLt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOpLt" ):
                return visitor.visitOpLt(self)
            else:
                return visitor.visitChildren(self)




    def opLt(self):

        localctx = QueryParser.OpLtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_opLt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 297
            self.match(QueryParser.LT_SGN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OpGtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GT_SGN(self):
            return self.getToken(QueryParser.GT_SGN, 0)

        def getRuleIndex(self):
            return QueryParser.RULE_opGt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpGt" ):
                listener.enterOpGt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpGt" ):
                listener.exitOpGt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOpGt" ):
                return visitor.visitOpGt(self)
            else:
                return visitor.visitChildren(self)




    def opGt(self):

        localctx = QueryParser.OpGtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_opGt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 299
            self.match(QueryParser.GT_SGN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OpMinusContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HYPHEN(self):
            return self.getToken(QueryParser.HYPHEN, 0)

        def getRuleIndex(self):
            return QueryParser.RULE_opMinus

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpMinus" ):
                listener.enterOpMinus(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpMinus" ):
                listener.exitOpMinus(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOpMinus" ):
                return visitor.visitOpMinus(self)
            else:
                return visitor.visitChildren(self)




    def opMinus(self):

        localctx = QueryParser.OpMinusContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_opMinus)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 301
            self.match(QueryParser.HYPHEN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OpSemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SEMI_COLON(self):
            return self.getToken(QueryParser.SEMI_COLON, 0)

        def getRuleIndex(self):
            return QueryParser.RULE_opSem

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpSem" ):
                listener.enterOpSem(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpSem" ):
                listener.exitOpSem(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOpSem" ):
                return visitor.visitOpSem(self)
            else:
                return visitor.visitChildren(self)




    def opSem(self):

        localctx = QueryParser.OpSemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_opSem)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 303
            self.match(QueryParser.SEMI_COLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HASHTAG(self):
            return self.getToken(QueryParser.HASHTAG, 0)

        def ddash(self):
            return self.getTypedRuleContext(QueryParser.DdashContext,0)


        def WS(self):
            return self.getToken(QueryParser.WS, 0)

        def getRuleIndex(self):
            return QueryParser.RULE_cmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCmt" ):
                listener.enterCmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCmt" ):
                listener.exitCmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCmt" ):
                return visitor.visitCmt(self)
            else:
                return visitor.visitChildren(self)




    def cmt(self):

        localctx = QueryParser.CmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_cmt)
        try:
            self.state = 309
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [QueryParser.HASHTAG]:
                self.enterOuterAlt(localctx, 1)
                self.state = 305
                self.match(QueryParser.HASHTAG)
                pass
            elif token in [QueryParser.HYPHEN]:
                self.enterOuterAlt(localctx, 2)
                self.state = 306
                self.ddash()
                self.state = 307
                self.match(QueryParser.WS)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DdashContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opMinus(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QueryParser.OpMinusContext)
            else:
                return self.getTypedRuleContext(QueryParser.OpMinusContext,i)


        def getRuleIndex(self):
            return QueryParser.RULE_ddash

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDdash" ):
                listener.enterDdash(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDdash" ):
                listener.exitDdash(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDdash" ):
                return visitor.visitDdash(self)
            else:
                return visitor.visitChildren(self)




    def ddash(self):

        localctx = QueryParser.DdashContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_ddash)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 311
            self.opMinus()
            self.state = 312
            self.opMinus()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QuoteContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def QUOTE(self):
            return self.getToken(QueryParser.QUOTE, 0)

        def getRuleIndex(self):
            return QueryParser.RULE_quote

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQuote" ):
                listener.enterQuote(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQuote" ):
                listener.exitQuote(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQuote" ):
                return visitor.visitQuote(self)
            else:
                return visitor.visitChildren(self)




    def quote(self):

        localctx = QueryParser.QuoteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_quote)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 314
            self.match(QueryParser.QUOTE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DquoteContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DQUOTE(self):
            return self.getToken(QueryParser.DQUOTE, 0)

        def getRuleIndex(self):
            return QueryParser.RULE_dquote

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDquote" ):
                listener.enterDquote(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDquote" ):
                listener.exitDquote(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDquote" ):
                return visitor.visitDquote(self)
            else:
                return visitor.visitChildren(self)




    def dquote(self):

        localctx = QueryParser.DquoteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_dquote)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 316
            self.match(QueryParser.DQUOTE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Us_sgnContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def US(self):
            return self.getToken(QueryParser.US, 0)

        def getRuleIndex(self):
            return QueryParser.RULE_us_sgn

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUs_sgn" ):
                listener.enterUs_sgn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUs_sgn" ):
                listener.exitUs_sgn(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUs_sgn" ):
                return visitor.visitUs_sgn(self)
            else:
                return visitor.visitChildren(self)




    def us_sgn(self):

        localctx = QueryParser.Us_sgnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_us_sgn)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 318
            self.match(QueryParser.US)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class C_andContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CH_AND(self):
            return self.getToken(QueryParser.CH_AND, 0)

        def getRuleIndex(self):
            return QueryParser.RULE_c_and

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterC_and" ):
                listener.enterC_and(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitC_and" ):
                listener.exitC_and(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitC_and" ):
                return visitor.visitC_and(self)
            else:
                return visitor.visitChildren(self)




    def c_and(self):

        localctx = QueryParser.C_andContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_c_and)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 320
            self.match(QueryParser.CH_AND)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class C_and_hexContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CH_AND_HEX(self):
            return self.getToken(QueryParser.CH_AND_HEX, 0)

        def getRuleIndex(self):
            return QueryParser.RULE_c_and_hex

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterC_and_hex" ):
                listener.enterC_and_hex(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitC_and_hex" ):
                listener.exitC_and_hex(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitC_and_hex" ):
                return visitor.visitC_and_hex(self)
            else:
                return visitor.visitChildren(self)




    def c_and_hex(self):

        localctx = QueryParser.C_and_hexContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_c_and_hex)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 322
            self.match(QueryParser.CH_AND_HEX)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class C_orContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CH_OR(self):
            return self.getToken(QueryParser.CH_OR, 0)

        def getRuleIndex(self):
            return QueryParser.RULE_c_or

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterC_or" ):
                listener.enterC_or(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitC_or" ):
                listener.exitC_or(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitC_or" ):
                return visitor.visitC_or(self)
            else:
                return visitor.visitChildren(self)




    def c_or(self):

        localctx = QueryParser.C_orContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_c_or)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 324
            self.match(QueryParser.CH_OR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class C_slashContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SLASH(self):
            return self.getToken(QueryParser.SLASH, 0)

        def getRuleIndex(self):
            return QueryParser.RULE_c_slash

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterC_slash" ):
                listener.enterC_slash(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitC_slash" ):
                listener.exitC_slash(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitC_slash" ):
                return visitor.visitC_slash(self)
            else:
                return visitor.visitChildren(self)




    def c_slash(self):

        localctx = QueryParser.C_slashContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_c_slash)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 326
            self.match(QueryParser.SLASH)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class C_dotContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DOT(self):
            return self.getToken(QueryParser.DOT, 0)

        def getRuleIndex(self):
            return QueryParser.RULE_c_dot

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterC_dot" ):
                listener.enterC_dot(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitC_dot" ):
                listener.exitC_dot(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitC_dot" ):
                return visitor.visitC_dot(self)
            else:
                return visitor.visitChildren(self)




    def c_dot(self):

        localctx = QueryParser.C_dotContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_c_dot)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 328
            self.match(QueryParser.DOT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class C_colonContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COLON(self):
            return self.getToken(QueryParser.COLON, 0)

        def getRuleIndex(self):
            return QueryParser.RULE_c_colon

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterC_colon" ):
                listener.enterC_colon(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitC_colon" ):
                listener.exitC_colon(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitC_colon" ):
                return visitor.visitC_colon(self)
            else:
                return visitor.visitChildren(self)




    def c_colon(self):

        localctx = QueryParser.C_colonContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_c_colon)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 330
            self.match(QueryParser.COLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class S_bslashContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def B_SLASH(self):
            return self.getToken(QueryParser.B_SLASH, 0)

        def getRuleIndex(self):
            return QueryParser.RULE_s_bslash

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterS_bslash" ):
                listener.enterS_bslash(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitS_bslash" ):
                listener.exitS_bslash(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitS_bslash" ):
                return visitor.visitS_bslash(self)
            else:
                return visitor.visitChildren(self)




    def s_bslash(self):

        localctx = QueryParser.S_bslashContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_s_bslash)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 332
            self.match(QueryParser.B_SLASH)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class C_qContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def QM(self):
            return self.getToken(QueryParser.QM, 0)

        def getRuleIndex(self):
            return QueryParser.RULE_c_q

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterC_q" ):
                listener.enterC_q(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitC_q" ):
                listener.exitC_q(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitC_q" ):
                return visitor.visitC_q(self)
            else:
                return visitor.visitChildren(self)




    def c_q(self):

        localctx = QueryParser.C_qContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_c_q)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 334
            self.match(QueryParser.QM)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Par_openContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PAR_O(self):
            return self.getToken(QueryParser.PAR_O, 0)

        def getRuleIndex(self):
            return QueryParser.RULE_par_open

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPar_open" ):
                listener.enterPar_open(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPar_open" ):
                listener.exitPar_open(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPar_open" ):
                return visitor.visitPar_open(self)
            else:
                return visitor.visitChildren(self)




    def par_open(self):

        localctx = QueryParser.Par_openContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_par_open)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 336
            self.match(QueryParser.PAR_O)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Par_closeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PAR_C(self):
            return self.getToken(QueryParser.PAR_C, 0)

        def getRuleIndex(self):
            return QueryParser.RULE_par_close

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPar_close" ):
                listener.enterPar_close(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPar_close" ):
                listener.exitPar_close(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPar_close" ):
                return visitor.visitPar_close(self)
            else:
                return visitor.visitChildren(self)




    def par_close(self):

        localctx = QueryParser.Par_closeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_par_close)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 338
            self.match(QueryParser.PAR_C)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class C_starContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STAR(self):
            return self.getToken(QueryParser.STAR, 0)

        def getRuleIndex(self):
            return QueryParser.RULE_c_star

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterC_star" ):
                listener.enterC_star(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitC_star" ):
                listener.exitC_star(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitC_star" ):
                return visitor.visitC_star(self)
            else:
                return visitor.visitChildren(self)




    def c_star(self):

        localctx = QueryParser.C_starContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_c_star)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 340
            self.match(QueryParser.STAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class C_percentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PERCENT(self):
            return self.getToken(QueryParser.PERCENT, 0)

        def getRuleIndex(self):
            return QueryParser.RULE_c_percent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterC_percent" ):
                listener.enterC_percent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitC_percent" ):
                listener.exitC_percent(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitC_percent" ):
                return visitor.visitC_percent(self)
            else:
                return visitor.visitChildren(self)




    def c_percent(self):

        localctx = QueryParser.C_percentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_c_percent)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 342
            self.match(QueryParser.PERCENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class C_brackContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BRACK(self):
            return self.getToken(QueryParser.BRACK, 0)

        def getRuleIndex(self):
            return QueryParser.RULE_c_brack

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterC_brack" ):
                listener.enterC_brack(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitC_brack" ):
                listener.exitC_brack(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitC_brack" ):
                return visitor.visitC_brack(self)
            else:
                return visitor.visitChildren(self)




    def c_brack(self):

        localctx = QueryParser.C_brackContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_c_brack)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 344
            self.match(QueryParser.BRACK)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class C_acoladContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ACOLAD(self):
            return self.getToken(QueryParser.ACOLAD, 0)

        def getRuleIndex(self):
            return QueryParser.RULE_c_acolad

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterC_acolad" ):
                listener.enterC_acolad(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitC_acolad" ):
                listener.exitC_acolad(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitC_acolad" ):
                return visitor.visitC_acolad(self)
            else:
                return visitor.visitChildren(self)




    def c_acolad(self):

        localctx = QueryParser.C_acoladContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_c_acolad)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 346
            self.match(QueryParser.ACOLAD)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class C_dollarContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DOLLAR(self):
            return self.getToken(QueryParser.DOLLAR, 0)

        def getRuleIndex(self):
            return QueryParser.RULE_c_dollar

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterC_dollar" ):
                listener.enterC_dollar(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitC_dollar" ):
                listener.exitC_dollar(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitC_dollar" ):
                return visitor.visitC_dollar(self)
            else:
                return visitor.visitChildren(self)




    def c_dollar(self):

        localctx = QueryParser.C_dollarContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_c_dollar)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 348
            self.match(QueryParser.DOLLAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class C_adsgnContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ADSGN(self):
            return self.getToken(QueryParser.ADSGN, 0)

        def getRuleIndex(self):
            return QueryParser.RULE_c_adsgn

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterC_adsgn" ):
                listener.enterC_adsgn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitC_adsgn" ):
                listener.exitC_adsgn(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitC_adsgn" ):
                return visitor.visitC_adsgn(self)
            else:
                return visitor.visitChildren(self)




    def c_adsgn(self):

        localctx = QueryParser.C_adsgnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_c_adsgn)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 350
            self.match(QueryParser.ADSGN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class C_irg1Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IRG_SGN1(self):
            return self.getToken(QueryParser.IRG_SGN1, 0)

        def getRuleIndex(self):
            return QueryParser.RULE_c_irg1

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterC_irg1" ):
                listener.enterC_irg1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitC_irg1" ):
                listener.exitC_irg1(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitC_irg1" ):
                return visitor.visitC_irg1(self)
            else:
                return visitor.visitChildren(self)




    def c_irg1(self):

        localctx = QueryParser.C_irg1Context(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_c_irg1)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 352
            self.match(QueryParser.IRG_SGN1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[0] = self.query_sempred
        self._predicates[2] = self.q_value_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def query_sempred(self, localctx:QueryContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 4)
         

    def q_value_sempred(self, localctx:Q_valueContext, predIndex:int):
            if predIndex == 1:
                return self.precpred(self._ctx, 3)
         




